# Exploration of Genotype data

Theww different use cases will be illustrated:

-   Basic information retrieval.
-   Basic statistics calculation.
-   Principal component analysis

For all the illustrated cases we will use dataset that contains all the information in a single file of GDS format, for information about this format please refer to the (official documentation)[https://bioconductor.org/packages/release/bioc/vignettes/gdsfmt/inst/doc/gdsfmt.html].

The phenotype information used throughout this section is not contained inside the GDS files mentioned previously, it is contained using traditional CSV/Excel files. This is to replicate the typical scenario where an investigator receives the genomic and phenotype data separated and has to merge it to study a specific relationship between the gene expression / variants and a certain phenotype.

The data used along this section is a synthetic data set generated by the CINECA project made freely available under the Creative Commons Licence (CC-BY) (funding: EC H2020 grant 825775). It has been pruned to provide a small dataset for easy and quick demnostration. Information on the dataset can be found on the Table \@ref(tab:tab1).

|                       |  Total |
|-----------------------|-------:|
| Number of SNPs        |651,808 |
| Number of individuals |  2,504 |

: (\#tab:tab1) Numer of SNPs and individuals by cohort

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: left;"><p>`r emo::ji("warning")` RESOURCES USED ALONG THIS SECTION</p></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><p>From <a href="https://opal-demo.obiba.org/">https://opal-demo.obiba.org/</a> :</p></td></tr><tr class="even"><td style="text-align: left;"><table><thead><tr class="header"><th><p>STUDY</p></th><th><p>TABLE</p></th><th><p>PROFILE</p></th></tr></thead><tbody><tr class="odd"><td><p>cohort1</p></td><td><p>OMICS.gds</p></td><td><p>omics</p></td></tr><tr
class="odd"><td><p>cohort1</p></td><td><p>GWAS.ega_phenotypes</p></td><td><p>omics</p></td></tr><tr 
</tbody></table></td></tr></tbody></table>

## Setting up

To begin, we will describe how to setup the work environment of the researcher to follow the use cases, this setup includes the following steps:

-   Connecting to the Opal server
-   Selecting the resources we need (genotype and phenotype)
-   Loading the data of the resources so we can begin working with it

### Connection to the Opal server

We have to create an Opal connection object to the cohort server. We do that using the following functions.

```{r exploration_ds_login, message=FALSE, warning=FALSE}
require('DSI')
require('DSOpal')
require('dsBaseClient')
require('dsOmicsClient')

builder <- DSI::newDSLoginBuilder()
builder$append(server = "cohort1", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
builder$append(server = "cohort2", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
builder$append(server = "cohort3", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
logindata <- builder$build()
conns <- DSI::datashield.login(logins = logindata)
```

### Assign the VCF resources

Now that we have created a connection object to the Opal, we have started a new R session on the server, our analysis will take place in this remote session, so we have to load the data into it.

In this use case we will use a resource from the `OMICS` project hosted on the [demo Opal server](https://opal-demo.obiba.org/). This resource corresponds to a GDS file with Genotype information. The names of the resource is `gds`. Following the Opal syntax, we will refer to it using the string `OMICS.gds`.

To load the resource we will use the `DSI::datashield.assign.resource()` function.

```{r exploration_assign_resources, message=FALSE, warning=FALSE, results=FALSE}
# Cohort 1 resources
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns[1], paste0("chr", x), paste0("GWAS.chr", x,"A"))
  })

# Cohort 2 resources
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns[2], paste0("chr", x), paste0("GWAS.chr", x,"B"))
  })

# Cohort 3 resources
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns[3], paste0("chr", x), paste0("GWAS.chr", x,"C"))
  })
```

Now we have assigned the resource named `OMICS.gds` into our remote R session into a variable  called `geno`. To verify this step has been performed correctly, we could use the `ds.class` function to check for their class and that it exists on the remote session.

```{r exploration_check_class_resource}
ds.class("chr1")
```

To resolve the resource and retrieve the data in the remote session we will use the `DSI::datashield.assign.expr()` function. This function runs a line of code on the remote session [^2], and in particular we want to run the function `as.resource.object()`, which is the DataSHIELD function in charge of resolving the resource.

[^2]: The same methodology and code can be used with unitary VCF resources that contain the variant information of all chromosomes.

```{r exploration_resolve_resources, message=FALSE, warning=FALSE, results=FALSE}
lapply(1:21, function(x){
  DSI::datashield.assign.expr(conns = conns, symbol = paste0("gds", x, "_object"),
                            expr = as.symbol(paste0("as.resource.object(chr", x, ")")))
})
```

Now we have resolved the resource named `geno` into our remote R session. The object retrieved have been assigned into a variable named `gds`. We can check the process was successful as we did before.

```{r exploration_check_class}
ds.class("gds")
```

### Assign the phenotypes

The object we have loaded into our remote session is a GDS file that containS genomic information of the individuals. Now we will include phenotype information and merge it together. The phenotypes information is a table that contains the individuals as rows and phenotypes as columns. In this use case, we will use a resource (as with the GDS file) to load the phenotypes table into the remote session.

|`r emo::ji("warning")`|  IMPORTANT INFORMATION |
|-----------------------|-------:|
|        |On this section, the phenotype information is used only on one occasion: when plotting the results of the PCA with a grouping variable. All the other functions can be used with what we have up to this point, you can skip to #basic-info and use `"gds"` instead of `"gds.Data"` if you are not interested on the PCA plot with groupings.|

The procedure is practically the same as before with some minor tweaks. Instead of using the function `as.resource.object`, we will use `as.resource.data.frame`, this is because before we were loading a special object (GDS file) and now we are loading a plain table, so the internal treatment on the remote session has to be different.

```{r exploration_assign_covariates_table}
# Cohort 1 phenotypes table
DSI::datashield.assign.resource(conns[1], "pheno", "GWAS.ega_phenotypes_1")

# Cohort 2 phenotypes table
DSI::datashield.assign.resource(conns[2], "pheno", "GWAS.ega_phenotypes_2")

# Cohort 3 phenotypes table
DSI::datashield.assign.resource(conns[3], "pheno", "GWAS.ega_phenotypes_3")

# Resolve phenotypes table
DSI::datashield.assign.expr(conns = conns, symbol = "pheno_object",
                            expr = quote(as.resource.data.frame(pheno)))
```

We can follow the same analogy as before to know that we have assigned the phenotypes table to a variable called `pheno_object` on the remote R session.

```{r exploration_check_class_table}
ds.class("pheno_object")
```

We can also check the column names to see which information is present on the table.

```{r exploration_check_table_cols}
ds.colnames("pheno_object")[[1]]
```

### Merge GDS (genotype) and phenotype information

Arrived at this point, we have a GDS object and a phenotypes table on our remote session. The next step is to merge them. Before doing that however, we have to gather some information from the phenotypes table. The information to gather is summarized on the Table \@ref(tab:tab2).

+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Information                                                   | Details                                                                                                                                                                                                                                            |
+===============================================================+====================================================================================================================================================================================================================================================+
| Which column has the samples identifier?                      | Column name that contains the IDs of the samples. Those are the IDs that will be matched to the ones present on the VCF objects.                                                                                                                   |
+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Which is the sex column on the covariates file?               | Column name that contains the sex information.                                                                                                                                                                                                     |
+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| How are males and how are females encoded into this column?   | There is not a standard way to encode the sex information, some people use 0/1; male/female; etc. Our approach uses a library that requires a specific encoding, for that reason we need to know the original encoding to perform the translation. |
+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

: (\#tab:tab2) Information to gather from the phenotypes table.

If we are not sure about the exact column names, we can use the function `ds.colnames` as we did before. Also, we can use the function `ds.table1D` to check the level names of the categorical variables.

```{r exploration_tables_of_columns, message=FALSE, warning=FALSE}
ds.table1D("pheno_object$sex")$counts
```

From the different functions we used, we can extract our answers (Summarized on the Table \@ref(tab:tab3))

+-----------------------------------------------------------------+-----------------------------+
| Question                                                        | Answer                      |
+=================================================================+=============================+
| Which column has the samples identifier?                        | "subject_id"                |
+-----------------------------------------------------------------+-----------------------------+
| Which is the sex column on the covariates file?                 | "sex"                       |
+-----------------------------------------------------------------+-----------------------------+
| How are males and how are females encoded into this column?     | "male"/"female"             |
+-----------------------------------------------------------------+-----------------------------+


: (\#tab:tab3) Summary of options from the example phenotypes table.

With all this information we can now merge the phenotypes and GDS object into a type of object named GenotypeData. We will use the `ds.GenotypeData` function.

```{r exploration_create_genoData, message=FALSE, warning=FALSE, results=FALSE}
lapply(1:21, function(x){
  ds.GenotypeData(x=paste0('gds', x,'_object'), covars = 'pheno_object',
                  columnId = "subject_id", sexId = "sex",
                  male_encoding = "male", female_encoding = "female",
                  case_control_column = "diabetes_diagnosed_doctor",
                  case = "Yes", control = "No",
                  newobj.name = paste0('gds.Data', x), datasources = conns)
})
```

The object we just created is named `gds.Data` on the remote session.

## Basic information of the Genotype data {#basic-info}

Once we have everything loaded in the remote R sessions, we can begin a simple exploratory analysis by checking basic information. We can check:

-   The number of variants and individuals
-   The chromosomes that are present on the data
-   The available phenotypes (only applies if we have merged phenotypes information)
-   Get the SNP rs IDs

To get the number of variants and individuals:

```{r genoDimensions}
dimensions <- do.call(rbind, lapply(1:21, function(x){
  data.frame(ds.genoDimensions(paste0('gds.Data', x)))
}))

data.frame(dimensions)
```

To get the chromosomes that are present on the data:

```{r genoChromosomes}
ds.getChromosomeNames('gds.Data1')
```

To get the available phenotypes:

```{r genoVariables}
ds.varLabels('gds.Data1')
```

To get the SNP rs IDs:

```{r genoSNPs}
head(ds.getSNPs('gds.Data1'))
```

## Basic statistics of the genotype data

We have also developed functions to compute statistics of the genotype data, the statistics implemented on `dsOmicsClient` are:

-   Allele frequencies. Brief definition (by Nature)[https://www.nature.com/scitable/definition/allele-frequency-298/#:~:text=An%20allele%20frequency%20is%20calculated,a%20percentage%2C%20or%20a%20fraction.].
-   Hardy-Weinberg Equilibrium testing. Information on the test can be found (here)[https://www.sciencedirect.com/science/article/pii/S0002929707607356https://www.sciencedirect.com/science/article/pii/S0002929707607356].

To get the allele frequencies:

```{r genoAlleleFreq}
ds.alleleFrequency(paste0('gds.Data', 1:21), type = "split")
```

To do the Hardy-Weinberg Equilibrium testing:

```{r genoHEWtesting}
do.call(rbind, lapply(1:21, function(x){
  data.frame(ds.exactHWE(paste0('gds.Data', x)))
}))
```

## Principal component analysis

```{r pcaExploration}
pca_res <- ds.PCA(paste0('gds.Data', 1:21), standardize = F, snpBlock = 10)
```

```{r pcaplotExploration}
plotPCA(pca_res, group = "sex")
```

