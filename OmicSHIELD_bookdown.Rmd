--- 
title: "Privacy protected federated omic data analysis in multi-center studies with DataSHIELD"
date: "`r Sys.Date()`"
output: bookdown::html_document2
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib]
biblio-style: apalike
link-citations: yes
---

```{r, setup, include=FALSE}
library(BiocStyle)
library(DSI)
library(DSOpal)
library(dsBaseClient)
library(DSLite)
library(dsOmicsClient)
# knitr::opts_chunk$set(eval = FALSE)
# knitr::opts_chunk$set(fig.width = 6)
knitr::opts_chunk$set(comment="", warning=FALSE, message=FALSE, cache=TRUE)
```

# Welcome {-}

![](fig/logo_omicshield.png){width=50%}

This is a website for a book that serves as official documentation for OmicSHIELD. On it you will find introductory references to learn about DataSHIELD and "resources", explanation on the type of analysis that can be performed using OmicSHIELD and workflows (with reproducible code) of the main functionalities of OmicSHIELD. Use cases in which OmicSHIELD is applied to real datasets are presented for illustrating the capabilities of the software for omic analyses (GWAS, transcriptomics and EWAS). 

This material is intended to be a quick reference guide for new researchers interested in this technology as well as to be an online companion for the manuscript "Privacy-protected federated omic data analysis in multi-center studies with OmicSHIELD".

All the functionalities described on this book have been developed at the Bioinformatic Research Group in Epidemiology (BRGE) of ISGlobal with external help from Yannick Marcon (Obiba); and are part of OmicSHIELD.

This website is free to use, and is licensed under a [MIT license](https://github.com/isglobal-brge/OmicSHIELD/blob/main/LICENSE).

<!--chapter:end:index.Rmd-->

# (PART) Preamble {.unnumbered}

# Introduction

## Materials to read beforehand

Along this book, there are some details regarding DataSHIELD and "resources" that are not explained in detail, it is expected that the reader is familiar with them. If that is not the case, there are other free online books/papers with that knowledge.

-   [DataSHIELD paper](https://academic.oup.com/ije/article/43/6/1929/707730?login=true): Description of what is DataSHIELD.

-   [DataSHIELD wiki](https://data2knowledge.atlassian.net/wiki/spaces/DSDEV/overview): Materials about DataSHIELD including:

    -   Beginner material
    -   Recorded DataSHIELD workshops
    -   Information on current release of DataSHIELD

-   [resource book](https://isglobal-brge.github.io/resource_bookdown/index.html): In this book you will find information about:

    -   DataSHIELD (Section 5)
    -   What are resources (Section 6/7)
    
We will be interacting with DataSHIELD through a data warehouse called Opal. This is the server that will handle the authentication of our credentials, storage of data and "resources" and will provide an R server where the non-disclosive analysis will be conducted. Information about it can also be foun online:

-   Opal papers [1](https://academic.oup.com/ije/article/46/5/1372/4102813?searchresult=1); [2](https://academic.oup.com/ije/article/46/5/1372/4102813?searchresult=1#112563630)
-   [Opal documentation](https://opaldoc.obiba.org/en/latest/)
    
## What are "resources": A very simple explanation without any technicalities

It is quite important to have a solid understanding of what are the "resources" and how we work with them, since in all the use cases we are interacting with them to load the Omic data on the R sessions. For that reason we included a very brief description of them without using technicalities.

The "resources" can be imagined as a data structure that contains the information about where to find a data set and the access credentials to it; we as DataSHIELD users are not able to look at this information (it is privately stored on the Opal server), but we can load it into our remote R session to make use of it. Following that, the next step comes naturally. 

Once we have in an R session the information to access a dataset (an ExpressionSet for example) we have to actually retrieve it on the remote R session to analyze it. This step is called resolving the resource.

Those two steps can be identified on the code we provide as the following:

Loading the information of a "resource":

```{r eval=FALSE}
DSI::datashield.assign.resource(conns, "resource", "resource.path.in.opal.server")
```

Resolving the "resource":

```{r eval=FALSE}
DSI::datashield.assign.expr(conns, "resource.resolved", expr = as.symbol("as.resource.object(resource)"))
```

This toy code would first load the "resource" on a variable called `resource` and it would retrieve the information it contains and assign it to a variable called `resource.resolved`.
    
## Capabilities of OmicSHIELD

The functionalities of OmicSHIELD are built on top of the "resources" to work with different types of data objects, more precisely we have developed capabilities to work with the following R objects:

-   ExpressionSet
-   RangedSummarizedExperiment
-   VCF/GDS (Genotype data containers)

These objects are analyzed using BioConductor packages as well as custom-made functions. This ensures that researchers familiar with the BioConductor universe will feel at home when using OmicSHIELD.

Not only we can work using a BioConductor approach, we also developed functionalities to make use of command line tools that are traditionally used on omics analysis, those are:

-   PLINK
-   SNPTEST

This allow the researchers to perform analysis on federated data using their own command line based pipelines. Again this ensures that people familiar with those tools will be able to perform analysis easily.

<!--chapter:end:01-intro.Rmd-->

# Omic data analysis: types of implemented analyses {#Omic}

The Figure \@ref(fig:opalOmic) describes the different types of 'omic association analyses that can be performed using DataSHIELD client functions implemented in the `r BiocStyle::Githubpkg("isglobal-brge/dsOmicsClient")` package. Basically, data ('omic and phenotypes/covariates) can be stored in different sites (http, ssh, AWS S3, local, ...) and are managed with Opal through the `r BiocStyle::Githubpkg("obiba/resourcer")` package and their extensions implemented in `r BiocStyle::Githubpkg("isglobal-brge/dsOmics")`.  


```{r opalOmic, echo=FALSE, fig.cap="Non-disclosive omic data analysis with DataSHIELD and Bioconductor. The figure illustrates how the `resourcer` package is used to get access to omic data through the Opal servers. Then DataSHIELD is used in the client side to perform non-disclosive data analyses.", fig.align="center"}
knitr::include_graphics("fig/dsOmics_A.jpg")
```

Then, `dsOmicsClient` package allows different types of analyses: pooled and meta-analysis. Both methods are based on fitting different Generalized Linear Models (GLMs) for each feature when assesing association between 'omic data and the phenotype/trait/condition of interest. Of course, non-disclosive 'omic data analysis from a single study can also be performed.

The **pooled approach** (Figure \@ref(fig:omicAnal1)) is recommended when the user wants to analyze 'omic data from different sources and obtain results as if the data were located in a single computer. It should be noted that this can be very time consuming when analyzing multiple features since it calls a base function in DataSHIELD (`ds.glm`) repeatedly. It also cannot be recommended when data are not properly harmonized (e.g. gene expression normalized using different methods, GWAS data having different platforms, ...). Furthermore when it is necesary to remove unwanted variability (for transcriptomic and epigenomica analysis) or control for population stratification (for GWAS analysis), this approach cannot be used since we need to develop methods to compute surrogate variables (to remove unwanted variability) or PCAs (to to address population stratification) in a non-disclosive way. 


The **meta-analysis approach** Figure \@ref(fig:omicAnal2) overcomes the limitations raised when performing pooled analyses. First, the computation issue is addressed by using scalable and fast methods to perform data analysis at whole-genome level at each location The transcriptomic and epigenomic data analyses make use of the widely used `r BiocStyle::Biocpkg("limma")` package that uses `ExpressionSet` or `RangedSummarizedExperiment` Bioc infrastructures to deal with 'omic and phenotypic (e.g covariates). The genomic data are analyzed using `r BiocStyle::Biocpkg("GWASTools")` and `r BiocStyle::Biocpkg("GENESIS")` that are designed to perform quality control (QC) and GWAS using GDS infrastructure.


Next, we describe how both approaches are implemented: 

- **Pooled approach:** Figure \@ref(fig:omicAnal1) illustrate how this analysis is performed. This corresponds to generalized linear models (glm) on data from single or multiple sources. It makes use of `ds.glm()` function which is a DataSHIELD function that uses an approach that is mathematically equivalent to placing all individual-level data froma all sources in one central warehouse and analysing those data using the conventional `glm()` function in R. The user can select one (or multiple) features (i.e., genes, transcripts, CpGs, SNPs, ...) 


```{r omicAnal1, echo=FALSE, fig.cap="Non-disclosive omic data analysis with DataSHIELD and Bioconductor. The figure illustrates how to perform single pooled omic data analysis. The analyses are performed by using a generalized linear model (glm) on data from one or multiple sources. It makes use of `ds.glm()`, a DataSHIELD function, that uses an approach that is mathematically equivalent to placing all individual-level data from all sources in one central warehouse and analysing those data using the conventional `glm()` function in R.", fig.align='center'}
knitr::include_graphics("fig/dsOmics_B.jpg")
```


- **Meta-analysis:** Figure \@ref(fig:omicAnal2) illustrate how this analysis is performed. This corresponds to performing a genome-wide analysis at each location using functions that are specifically design for that purpose and that are scalable. Then the results from each location can be meta-analyzed using methods that meta-analyze either effect sizes or p-values.


```{r omicAnal2, echo=FALSE, fig.cap="Non-disclosive omic data analysis with DataSHIELD and Bioconductor. The figure illustrates how to perform anlyses at genome-wide level from one or multiple sources. It runs standard Bioconductor functions at each server independently to speed up the analyses and in the case of having multiple sources, results can be meta-analyzed uning standar R functions.", fig.align='center'}
knitr::include_graphics("fig/dsOmics_C.jpg")
```

<!--chapter:end:02-types_analysis.Rmd-->


# Datasets description. {#DatasetsDescription}

Here, we will **describe the data employed for the analyses presented in the bookdown**, giving details about **experimental designs**, the type of **features available**, and the **structure and organization** of data in the [**Opal infrastructure**](https://opaldoc.obiba.org/en/latest/). Employed data constitute both **public data** downloaded from public repositories, and **real datasets** deriving from an European H2020 research project on exposome and health ([HELIX Project](https://www.projecthelix.eu)). The public datasets have been uploaded to the [Opal demo site](https://opal-demo.obiba.org/) and can be easily accessed without additional permissions. On the other hand, the **HELIX** dataset is available in the [Opal BRGE site](https://datashield.isglobal.org/repo) hosted by the [Bioinformatic Research Group in Epidemiology](https://brge.isglobal.org/) of ISGlobal. In both cases, data are organized in the Opal simulating a **single-site DataSHIELD infrastructure**. Details for **accessing** the server will be found in each section, at the beginning of each pipeline.

## CINECA project. {#CINECAdescription}

Data from the public CINECA project were employed in this bookdown for demonstrating the capabilities of dsOmicSHIELD for performing **GWAS and other genetic analyses**. Data correspond to synthetic data set generated by the [CINECA Project](https://www.cineca-project.eu/) made freely available under the Creative Commons Licence (CC-BY) (funding: EC H2020 grant 825775). In **Figure \@ref(fig:figCINECA)**, an overall description of the datasets and cohorts belonging to the **CINECA project** is presented. 

```{r figCINECA, echo=FALSE, fig.cap="The figure depicts CINECA project cohorts representing >1.4 Million individuals and spanning three continents.", fig.align='center'}
knitr::include_graphics("https://images.squarespace-cdn.com/content/v1/5cc2c7b2d86cc9589d33dfcc/1573825882582-AS6SBW8PMXNGKSJWS79H/cohort_figure_updated_Nov2019.png?format=750w")
```

## Data organization in the Opal server. {#CINECAopal}

Data were initially accessible from a public EGA repository (ID: [EGAD00001006673](https://ega-archive.org/studies/EGAS00001002472/)), being a deliverable of the [VEIS project](https://veis.bsc.es/en/). Previous to analysis, data were **pruned**, and the individuals were separated into **three synthetic cohorts**. Information on individuals and SNP count of each cohort can be found on the Table \@ref(tab:tab1).

|                       | Cohort 1 | Cohort 2 | Cohort 3 |   Total |
|-----------------------|---------:|---------:|---------:|--------:|
| Number of SNPs        |  865,240 |  865,240 |  865,240 | 865,240 |
| Number of individuals |      817 |    1,073 |      614 |   2,504 |

: (\#tab:tab1) Number of SNPs and individuals by cohort

The three datasets were uploaded to the [Opal demo site](https://opal-demo.obiba.org/) organized as (1) an array of **resource** objects, corresponding to unitary VCF files with variant information (one per chromosome and cohort), and (2) **table** objects corresponding to the phenotype data (one per cohort). Data are in Opal simulating a **single-site DataSHIELD architecture**, as in **Figure \@ref(fig:FigCINECAopal)**. In this figure, the data analyst corresponds to the "RStudio" session, which through the **DataSHIELD Interface (DSI)** connects with the Opal server located at the cohort network. 

```{r FigCINECAopal, echo=FALSE, fig.align = 'center', out.width = "90%", fig.cap="Proposed infrastructure to perform single-cohort GWAS studies.", fig.align='center'}
knitr::include_graphics("fig/single_cohort.png")
```

For more information about **DataSHIELD data formats**, please, refers to the bookdown [*"Orchestrating privacy-protected non-disclosive big data analyses of data from different resources with R and DataSHIELD"*](https://isglobal-brge.github.io/resource_bookdown/index.html). 

## TCGA Liver project. {#TCGALiverdatadescription}

The public TCGA Liver project was selected for illustrating how to perform **transcriptomic data analysis** in DataSHIELD. These data derived from the famous [TCGA project](https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga). We have uploaded to the demo Opal server a resource called `tcga_liver` whose URL is <http://duffel.rail.bio/recount/TCGA/rse_gene_liver.Rdata> available through the [recount project](https://jhubiostatistics.shinyapps.io/recount/). 

Some summaries of the dataset are the following:

|                               | TCGA Liver data |
|-------------------------------|-----------------|
| **Number of individuals**     |    424          |
| **Number of genes**           | 58,037          |
| **Number of covariate fields**|    864          |

The `RangedSummarizedExperiment` (RSE) objects are part of the [BioConductor project](https://www.bioconductor.org/), as a brief summary, these types of objects are designed to contain different multi-omic data, they can also contain the individuals phenotypes and additional metadata associated with a particular experiment. For further information about what are `RangedSummarizedExperiment` please take a look at the [official documentation](https://www.bioconductor.org/packages/devel/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html)

The resource used on this project contains a `RangedSummarizedExperiment` with the RNAseq profiling of liver cancer data from TCGA. The resource is located inside the `OMICS` project. The structure used is illustrated on the following figure.

```{r dgeProposal_1, echo=FALSE, fig.cap="Proposed infrastructure to perform DGE studies.", fig.align='center'}
knitr::include_graphics("fig/dge_structure.png")
```

The data analyst corresponds to the “RStudio” session, which through DataSHIELD Interface (DSI) connects with the Opal server. This Opal server contains a resource that corresponds to the TCGA liver RSE.

## Epigenetic data from the GSE66351 project {#GSE66351description}

The public data from the GSE66351 project were used in this section for illustrating how to perform **EWAS** in DataSHIELD. They has been downloaded from [GEO](https://www.ncbi.nlm.nih.gov/geo/) (accession number GSE66351) and consist on DNA methylation reads from the Illumina 450K array. Data corresponds to CpGs beta values measured in the superior temporal gyrus and prefrontal cortex brain regions of patients with Alzheimer's.

This kind of data is encapsulated on a type of R object called `ExpressionSet`, this objects are part of the [BioConductor project](https://www.bioconductor.org/) and are meant to contain different sources of genomic data, alongside the genomic data they can also contain the phenotypes and metadata associated to a study. Researchers who are not familiar with `ExpressionSet` can find further information [here](https://www.bioconductor.org/packages/release/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf). Notice that genomic data is encoded as beta-values that ensure data harmonization across studies.

In order to illustrate how to perform data analyses using federated data, we have split the data into two synthetic cohorts (split by individuals). We have created two resources on the demo Opal server called `GSE66351_1` and `GSE66351_2` respectively. They can be found inside the `OMICS` project. The structure used is illustrated on the following figure.

```{r ewasProposal_1, echo=FALSE, fig.cap="Proposed infrastructure to perform EWAS studies.", fig.align='center'}
knitr::include_graphics("fig/ewas_structure.png")
```

Some summaries of the datasets are the following:

|                               | Cohort 1 | Cohort 2 |   Total |
|-------------------------------|---------:|---------:|--------:|
| Number of CpGs                |  481,868 |  481,868 | 481,868 |
| Number of individuals         |      100 |       90 |     190 |
| Number of covariates          |       49 |       49 |      49 |
| Number of annotation features |       37 |       37 |      37 |

## HELIX project. {#HELIXdescription}

The real-world research problem presented in this book comes from the [HELIX Project](https://www.projecthelix.eu). The **HELIX (Human Early-Life Exposome) project** gathers data from **6 longitudinal-based European birth cohorts**, with the aim of evaluating the effect of **environmental risk factors** on **mothers and children health**, with a special focus in the effects on **molecular health profiles (omic data)**. **HELIX cohorts** include the _BIB_ (Born in Bradford) (United Kingdom), _EDEN_ (Étude des Déterminants pré et postnatals du développement et de la santé de l’ENfant) (France), _INMA_ (INfancia y Medio Ambiente) (Spain), _KANC_ (Kaunus Cohort) (Lithuania), _MoBa_ (Norwegian Mother and Child Cohort Study) (Norway), and _Rhea_ (Mother-Child Cohort in Crete) (Greece). General details of the **study design** of **HELIX** can be found in the **Figure \@ref(fig:FigHELIX)**. The whole **HELIX dataset** includes a total of 31,472 mother-child pairs. Among them, a **subcohort of 1,301 children** (approximately 200 children in each cohort) was selected **here** according to the following criteria of eligibility: 1) age 6 to 11 years; 2) omic data available (including gene expression and EWAS data); 3) complete address history; and 4) no serious health problems that may affect the clinical testing or the child safety. 

```{r FigHELIX, echo=FALSE, fig.align = 'center', out.width = "90%", fig.cap="General overview of the HELIX research project.", fig.align='center'}
knitr::include_graphics("http://www.projecthelix.eu/images/estructura/helix_study.gif")
```

In the **1,301 children**, a wide range of **environmental exposures** were evaluated to define the early-life exposome during **two time periods**: the **prenatal pregnancy period** and **childhood** (age 6 to 11 years). Collected exposures can be organized into three main parts of the **exposome**: **outdoor exposures, chemical exposures measured through biomarkers, and lifestyle factors**. All variables incorporated in the dataset have been appropriately **pre-processed** previous to analysis (outliers removal, normalization, and missing values imputation). Regarding **phenotype data**, a wide range of **health outcomes** are also available for the **childhood** period including phenotypes related to (1) obesity and cardiometabolic health, (2) respiratory health, and (3) cognition and mental health. Finally, **omic data** (mainly **transcriptomic** and **genome-wide DNA methylation data**) are also available in the **childhood** period. The **objective** of this dataset was illustrating a real case study of:

* Differential **gene expression** analysis. 
* Differential **DNA methylation** analysis. 

### Data organization in the Opal server. {#HELIXopal}

**Omic** data from the **HELIX project** were uploaded into to the [Opal BRGE site](https://datashield.isglobal.org/brge/ui/index.html) simulating a **single-site DataSHIELD architecture**, as illustrated in **Figure \@ref(fig:FigHELIXopal)**. Data were stored under the form of **resources** (one per cohort and data type). As illustrated in the figure, transcriptomic data) were stored under the form of _expressionSets_ while EWAS data were stored as _GenomicRatioSet_. A summary of the structure and organization of this data in the **Opal** for the **HELIX project** is illustrated in **Figure \@ref(fig:FigHELIXopal)**.

```{r FigHELIXopal, echo=FALSE, fig.align = 'center', out.width = "90%", fig.cap = "Input HELIX datasets organized by cohort in the Opal server."}
knitr::include_graphics(here::here("./fig", "HELIX OPAL STRUCTURE.png"))
```

In the next subsection, we present **extra details** for each of these datasets.

#### Gene expression data. {#TranscriptomicsHELIXDatadescript}

The **gene expression** data available for the **HELIX cohorts** correspond to **microarray data** deriving from the _Human Transcriptome Array 2.0_ platform of Affymetrix. These are hosted in the the [Opal BRGE site](https://datashield.isglobal.org/brge/ui/index.html) as _ExpressionSet_ objects. Particularly, one _ExpressionSet_ file per cohort is hosted in the [Opal BRGE site](https://datashield.isglobal.org/brge/ui/index.html) in the form of a **resource**, as presented in the **Figure \@ref(fig:FigHELIXresourcesOpal_transcrip)**. As it can be seen, data are organized within the Opal server in a **project** called **HELIX_omics**.

```{r FigHELIXresourcesOpal_transcrip, echo=FALSE, fig.align = 'center', out.height = "500px", out.width = "3000px", fig.cap = "Input ExposomeSet data organized by cohort in the Opal server as resources."}
knitr::include_graphics(here::here("./fig", "geneexpression_HELIX.png"))
```

#### Epigenetic data. {#EWASHELIXDatadescript}

The **epigenetic** data available for the **HELIX cohorts** correspond to genome-wide **DNA methylation data** obtained by microarray experiments using the _Infinium HumanMethylation450k_ platform from Illumina. The data format in which these data are hosted in the Opal is the type **GenomicRatioSet**. **GenomicRatioSet** is a extend of the class **SummarizedExperiment** especially designed for DNA methylation data obtained with the _Infinium HumanMethylation450k_ platform, that will be analysed with the associated R package [minfi](http://bioconductor.org/packages/release/bioc/html/minfi.html). This type of data usually contain **pre-processed DNA methylation values** at a genome-wide level, in the form of **M or/and Beta values**, together with the associated **genomic coordinates**. As in the case of **ExpressionSet** types, **GenomicRatioSet** can also incorporate **phenotype** and **metadata** information.

Particularly, one  **GenomicRatioSet** file per cohort is hosted in the [Opal BRGE site](https://datashield.isglobal.org/brge/ui/index.html) in the form of a **resource**, as presented in the **Figure \@ref(fig:FigHELIXresourcesOpal_DNAm)**. As it can be seen, data are organized within the Opal server in a **project** called **HELIX_omics**.

```{r FigHELIXresourcesOpal_DNAm, echo=FALSE, fig.align = 'center', out.height = "500px", out.width = "3000px", fig.cap = "Input GenomicRatioSet data organized by cohort in the Opal server as resources."}
knitr::include_graphics(here::here("./fig", "dnaM_HELIX.png"))
```

# (PART) Workflows {.unnumbered}

<!--chapter:end:03-Projects_description.Rmd-->

# Genome wide association study (GWAS) analysis

Three different use cases will be illustrated in this section:

-   Single cohort GWAS. Using data from all the individuals.
-   Multi-cohort GWAS. Using the same individuals as the single cohort separated into three synthetic cohorts.
-   Polygenic risk score. Using data from all the individuals.

For this, we will be using data from the CINECA project presented in the section \@ref(CINECAdescription). For all the illustrated cases we will use data divided by chromosome (VCF files). The procedure is the same if all the variants are on a single VCF. The phenotype information used throughout this section is not contained inside the VCF files mentioned previously, it is contained using traditional CSV/Excel files. This is to replicate the typical scenario where an investigator receives the genomic and phenotype data separated and has to merge it to study a specific relationship between the gene expression / variants and a certain phenotype.

## Single cohort

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: left;"><p>`r emo::ji("warning")` RESOURCES USED ALONG THIS SECTION</p></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><p>From <a href="https://opal-demo.obiba.org/">https://opal-demo.obiba.org/</a> :</p></td></tr><tr class="even"><td style="text-align: left;"><table><thead><tr class="header"><th><p>STUDY</p></th><th><p>TABLE</p></th><th><p>PROFILE</p></th></tr></thead><tbody><tr class="odd"><td><p>cohort1</p></td><td><p>GWAS.chr{1..21}</p></td><td><p>omics</p></td></tr><tr
class="odd"><td><p>cohort1</p></td><td><p>GWAS.ega_phenotypes</p></td><td><p>omics</p></td></tr><tr 
</tbody></table></td></tr></tbody></table>

The single cohort analysis is a way of performing a GWAS study guaranteeing GDPR data confidentiality. The structure followed is illustrated on the following figure.

```{r singleCohortImage, echo=FALSE, fig.cap="Proposed infrastructure to perform single-cohort GWAS studies.", fig.align='center'}
knitr::include_graphics("fig/single_cohort.png")
```

The data analyst corresponds to the "RStudio" session, which through DataSHIELD Interface (DSI) connects with the Opal server located at the cohort network. This Opal server contains an array of resources that correspond to the different VCF files (sliced by chromosome) [^1] and a resource that corresponds to the phenotypes table of the studied individuals.

[^1]: The same methodology and code can be used with unitary VCF resources that contain the variant information of all chromosomes.

### Connection to the Opal server

We have to create an Opal connection object to the cohort server. We do that using the following functions.

```{r single_cohort_ds_login, message=FALSE, warning=FALSE}
require('DSI')
require('DSOpal')
require('dsBaseClient')
require('dsOmicsClient')

builder <- DSI::newDSLoginBuilder()
builder$append(server = "cohort1", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
logindata <- builder$build()
conns <- DSI::datashield.login(logins = logindata)
```

### Assign the VCF resources

Now that we have created a connection object to the Opal, we have started a new R session on the server, our analysis will take place in this remote session, so we have to load the data into it.

In this use case we will use 21 different resources from the `GWAS` project hosted on the [demo Opal server](https://opal-demo.obiba.org/). This resources correspond to VCF files with information on individual chromosomes. The names of the resources are `chrXX` (where XX is the chromosome number). Following the Opal syntax, we will refer to them using the string `GWAS.chrXX`.

To load the resources we will use the `DSI::datashield.assign.resource()` function. Note that along the use case we use the `lapply` function to simplify our code since we have to perform repetitive operations. `lapply` is a way of creating loops in R, for more information visit [the documentation](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/lapply).

```{r single_cohort_assign_resources, message=FALSE, warning=FALSE, results=FALSE}
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns, paste0("chr", x), paste0("GWAS.chr", x))
  })
```

Now we have assigned all the resources named `GWAS.chrXX` into our remote R session. We have assigned them to the variables called `chrXX`. To verify this step has been performed correctly, we could use the `ds.class` function to check for their class and that they exist on the remote session.

```{r single_cohort_check_class_resource}
ds.class("chr1")
```

To resolve the resources and retrieve the data in the remote session we will use the `DSI::datashield.assign.expr()` function. This function runs a line of code on the remote session [^2], and in particular we want to run the function `as.resource.object()`, which is the DataSHIELD function in charge of resolving the resources.

[^2]: The same methodology and code can be used with unitary VCF resources that contain the variant information of all chromosomes.

```{r single_cohort_resolve_resources, message=FALSE, warning=FALSE, results=FALSE}
lapply(1:21, function(x){
  DSI::datashield.assign.expr(conns = conns, symbol = paste0("gds", x, "_object"),
                            expr = as.symbol(paste0("as.resource.object(chr", x, ")")))
})
```

Now we have resolved the resources named `chrXX` into our remote R session. The objects retrieved have been assigned into variables named `gdsXX_object`. We can check the process was successful as we did before.

```{r single_cohort_check_class}
ds.class("gds1_object")
```

### Assign the phenotypes

The objects we have loaded into our remote session are VCF files that contain genomic information of the individuals. To perform a GWAS this information has to be related to some phenotypes to extract relationships. Therefore, we need to load the phenotypes into the remote session. The phenotypes information is a table that contains the individuals as rows and phenotypes as columns. In this use case, we will use a resource (as with the VCF files) to load the phenotypes table into the remote session.

The procedure is practically the same as before with some minor tweaks. To begin, we have the phenotypes information in a single table (hence, a single resource). Then, instead of using the function `as.resource.object`, we will use `as.resource.data.frame`, this is because before we were loading a special object (VCF file) and now we are loading a plain table, so the internal treatment on the remote session has to be different.

```{r single_cohort_assign_covariates_table}
DSI::datashield.assign.resource(conns, "pheno", "GWAS.ega_phenotypes")
DSI::datashield.assign.expr(conns = conns, symbol = "pheno_object",
                            expr = quote(as.resource.data.frame(pheno)))
```

We can follow the same analogy as before to know that we have assigned the phenotypes table to a variable called `pheno_object` on the remote R session.

```{r single_cohort_check_class_table}
ds.class("pheno_object")
```

We can also check the column names to see which information is present on the table.

```{r single_cohort_check_table_cols}
ds.colnames("pheno_object")[[1]]
```

### Merge VCF (genotype) and phenotype information {#vcf_merge}

Arrived at this point, we have 21 VCF objects (each one corresponds to a chromosome) and a phenotypes table on our remote session. The next step is merging each of the VCF objects with the phenotypes table. Before doing that however, we have to gather some information from the phenotypes table. The information to gather is summarized on the Table \@ref(tab:tab2).

+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Information                                                   | Details                                                                                                                                                                                                                                            |
+===============================================================+====================================================================================================================================================================================================================================================+
| Which column has the samples identifier?                      | Column name that contains the IDs of the samples. Those are the IDs that will be matched to the ones present on the VCF objects.                                                                                                                   |
+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Which is the sex column on the covariates file?               | Column name that contains the sex information.                                                                                                                                                                                                     |
+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| How are males and how are females encoded into this column?   | There is not a standard way to encode the sex information, some people use 0/1; male/female; etc. Our approach uses a library that requires a specific encoding, for that reason we need to know the original encoding to perform the translation. |
+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Which is the case-control column?                             | Column name that contains the case/control to be studied.                                                                                                                                                                                          |
+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| What is the encoding for case and for control on this column? | Similar as the sex column, the case/control will be translated to the particular standard of the software we have used to develop our functionalities [^3] .                                                                                       |
+---------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

: (\#tab:tab2) Information to gather from the phenotypes table.

[^3]: It's important to note that all the other encodings present on the case-control column that are not the case or control, will be turned into missings. As an example, if we have `"cancer"`/`"no cancer"`/`"no information"`/`"prefer not to answer"` we can specifcy `case="cancer"`, `control="no cancer"` and all the individuals with `"no information"`/`"prefer not to answer"` will be interpreted as missings.

If we are not sure about the exact column names, we can use the function `ds.colnames` as we did before. Also, we can use the function `ds.table1D` to check the level names of the categorical variables.

```{r single_cohort_tables_of_columns, message=FALSE, warning=FALSE}
ds.table1D("pheno_object$sex")$counts
ds.table1D("pheno_object$diabetes_diagnosed_doctor")$counts
```

From the different functions we used, we can extract our answers (Summarized on the Table \@ref(tab:tab3))

+-----------------------------------------------------------------+-----------------------------+
| Question                                                        | Answer                      |
+=================================================================+=============================+
| Which column has the samples identifier?                        | "subject_id"                |
+-----------------------------------------------------------------+-----------------------------+
| Which is the sex column on the covariates file?                 | "sex"                       |
+-----------------------------------------------------------------+-----------------------------+
| How are males and how are females encoded into this column?     | "male"/"female"             |
+-----------------------------------------------------------------+-----------------------------+
| Which is the case-control column of interest of the covariates? | "diabetes_diagnosed_doctor" |
+-----------------------------------------------------------------+-----------------------------+
| What is the encoding for case and for control on this column?   | "Yes"/"No"                  |
+-----------------------------------------------------------------+-----------------------------+

: (\#tab:tab3) Summary of options from the example phenotypes table.

With all this information we can now merge the phenotypes and VCF objects into a type of object named GenotypeData. We will use the `ds.GenotypeData` function.

```{r single_cohort_create_genoData, message=FALSE, warning=FALSE, results=FALSE}
lapply(1:21, function(x){
  ds.GenotypeData(x=paste0('gds', x,'_object'), covars = 'pheno_object', 
                  columnId = "subject_id", sexId = "sex", 
                  male_encoding = "male", female_encoding = "female",
                  case_control_column = "diabetes_diagnosed_doctor", 
                  case = "Yes", control = "No", 
                  newobj.name = paste0('gds.Data', x), datasources = conns)
})
```

The objects we just created are named `gds.DataXX` on the remote session. Now we are ready to perform a GWAS analysis. To perform a GWAS we have to supply this "Genotype Data" objects and some sort of formula in which we will specify the type of association we are interested on studying. The R language has it's own way of writing formulas, a simple example would be the following (relate the `condition` to the `smoke` variable adjusted by `sex`):

```{r eval=F}
condition ~ smoke + sex
```

For this use case we will use the following formula.

```{r eval=F}
diabetes_diagnosed_doctor ~ sex + hdl_cholesterol
```

### Performing the GWAS

We are finally ready to achieve our ultimate goal, performing a GWAS analysis. We have our data (genotype + phenotypes) organized into the correspondent objects (GenotypeData) and our association formula ready. The function `ds.metaGWAS` is in charge of doing the analysis, we have to supply it with the names of the GenotypeData objects of the remote R session and the formula. Since we have 21 different objects, the `paste0` function is used to simplify the call.

```{r single_cohort_GWAS, message=FALSE, warning=FALSE}
results_single <- ds.metaGWAS(genoData = paste0("gds.Data", 1:21), 
                              model = diabetes_diagnosed_doctor ~ sex + hdl_cholesterol)[[1]]

results_single
```

We can display the results of the GWAS using a Manhattan plot.

```{r singleCohortManhattan_plot, message=FALSE, warning=FALSE, fig.cap="Manhattan plot of the single-cohort results.", fig.align='center'}
manhattan(results_single)
```

Moreover, we can visualize the region with the lowest p-value in detail using the function `LocusZoom`. There are multiple arguments to control the gene annotation, display a different region of the GWAS, display a different range of positions and more. Make sure to check `?LocusZoom` for all the details.

```{r locuszoom, message=FALSE, warning=FALSE, fig.cap="LocusZoom plot of the surrounding region of the top hit SNP.", fig.align='center'}
LocusZoom(results_single, use_biomaRt = FALSE)
```

```{r}
datashield.logout(conns)
```

## Multi cohorts

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: left;"><p>`r emo::ji("warning")` RESOURCES USED ALONG THIS SECTION</p></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><p>From <a href="https://opal-demo.obiba.org/">https://opal-demo.obiba.org/</a> :</p></td></tr><tr class="even"><td style="text-align: left;"><table><thead><tr class="header"><th><p>STUDY</p></th><th><p>TABLE</p></th><th><p>PROFILE</p></th></tr></thead><tbody><tr class="odd"><td><p>cohort1</p></td><td><p>GWAS.chr{1..21}A</p></td><td><p>omics</p></td></tr><tr
class="odd"><td><p>cohort2</p></td><td><p>GWAS.chr{1..21}B</p></td><td><p>omics</p></td></tr><tr 
class="odd"><td><p>cohort3</p></td><td><p>GWAS.chr{1..21}C</p></td><td><p>omics</p></td></tr><tr 
class="odd"><td><p>cohort1</p></td><td><p>GWAS.ega_phenotypes_1</p></td><td><p>omics</p></td></tr><tr 
class="odd"><td><p>cohort2</p></td><td><p>GWAS.ega_phenotypes_2</p></td><td><p>omics</p></td></tr><tr 
class="odd"><td><p>cohort3</p></td><td><p>GWAS.ega_phenotypes_3</p></td><td><p>omics</p></td></tr><tr 
</tbody></table></td></tr></tbody></table>

Now all the individuals used for the single cohort use case will be divided into three different synthetic cohorts. The results from each cohort will then be meta-analyzed to be compared to the results obtained by studying all the individuals together. As with the single-cohort methodology illustrated on the prior section, this method guarantees GDPR data confidentiality. The structure for a three cohort study is illustrated on the following figure (note this can be extrapolated for cohorts with a bigger (or lower) partner count).

```{r multiCohortImage, echo=FALSE, fig.cap="Proposed infrastructure to perform multi-cohort GWAS studies.", fig.align='center'}
knitr::include_graphics("fig/multi_cohort.png")
```

The data analyst corresponds to the "RStudio" session, which through DataSHIELD Interface (DSI) connects with the Opal server located at the cohort network. This Opal server contains an array of resources that correspond to the different VCF files (sliced by chromosome) [^4] and a resource that corresponds to the phenotypes table of the studied individuals.

[^4]: The same methodology and code can be used with unitary VCF resources that contain the variant information of all chromosomes.

This use case will portray a complete study methodology, more precisely we will follow this flowchart:

```{r multiCohortFlowchart, echo=FALSE, fig.cap="Flowchart to perform multi-cohort GWAS studies. Adapted from @winkler2014quality", fig.align='center', dpi=300}
knitr::include_graphics("fig/multi_cohort_flowchart.png")
```

Brief description of each step:

-   **Step 1:** Logging into the Opal servers and load all the VCF files to the remote R sessions. Corresponds to the sections [Connection to the Opal server](#connection-to-the-opal-server-2), [Assign the VCF resources](#multi-vcf), [Assign the phenotypes](#assign-the-phenotypes-1) and [Merge VCF (genotype) and phenotype information](#merge-vcf-genotype-and-phenotype-information).
-   **Step 2:** Performing a GWAS analysis on each cohort and collect all the aggregated non-disclosive statistics. Corresponds to the sections [Performing the GWAS](#performing-the-gwas-1) and [GWAS Plots].
-   **Step 3:** Apply different QC control methodologies to assess possible problems on the data used on each cohort to perform the analysis. Corresponds to the section [Meta-level quality control].
-   **Step 4:** Perform the meta-analysis of the aggregated statistics. Corresponds to the section [Meta-analysis](#meta-analysis-2).
-   **Step 5:** Perform a pooled ultra fast GWAS and compare the results to the ones of the meta-analysis. Corresponds to the section [Ultra fast GWAS](#ultra-fast-gwas).
-   **Step 6:** Perform post-omics analysis: Enrichment analysis. Corresponds to the section [Post-omic analysis](#post-omics).

### Connection to the Opal server

We have to create an Opal connection object to the different cohorts server. We do that using the following functions.

```{r multi_cohort_ds_login, message=FALSE, warning=FALSE}
require('DSI')
require('DSOpal')
require('dsBaseClient')
require('dsOmicsClient')

builder <- DSI::newDSLoginBuilder()
builder$append(server = "cohort1", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
builder$append(server = "cohort2", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
builder$append(server = "cohort3", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
logindata <- builder$build()
conns <- DSI::datashield.login(logins = logindata)
```

It is important to note that in this use case, we are only using one server that contains all the resources (<https://opal-demo.obiba.org/>), on this server there are all the resources that correspond to the different cohorts. On a more real scenario each one of the `builder$append` instructions would be connecting to a different server.

### Assign the VCF resources {#multi-vcf}

Now that we have created a connection object to the different Opals, we have started three R session, our analysis will take place on those remote sessions, so we have to load the data into them.

In this use case we will use 63 different resources from the `GWAS` project hosted on the [demo Opal server](https://opal-demo.obiba.org/). This resources correspond to VCF files with information on individual chromosomes (21 chromosomes per three cohorts). The names of the resources are `chrXXY` (where XX is the chromosome number and Y is the cohort A/B/C). Following the Opal syntax, we will refer to them using the string `GWAS.chrXXY`.

We have to refer specifically to each different server by using `conns[X]`, this allows us to communicate with the server of interest to indicate to it the resources that it has to load.

```{r multi_cohort_assign_resources, message=FALSE, warning=FALSE, results=FALSE}
# Cohort 1 resources
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns[1], paste0("chr", x), paste0("GWAS.chr", x,"A"))
  })

# Cohort 2 resources
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns[2], paste0("chr", x), paste0("GWAS.chr", x,"B"))
  })

# Cohort 3 resources
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns[3], paste0("chr", x), paste0("GWAS.chr", x,"C"))
  })
```

Now we have assigned all the resources named `GWAS.chrXXY` into our remote R session. We have assigned them to the variables called `chrXX`. To verify this step has been performed correctly, we could use the `ds.class` function to check for their class and that they exist on the remote sessions.

```{r multi_cohort_check_class_resource}
ds.class("chr1")
```

We can see that the object `chr1` exists in all the three servers.

Finally the resources are resolved to retrieve the data in the remote sessions.

```{r multi_cohort_resolve_resources, message=FALSE, warning=FALSE, results=FALSE}
lapply(1:21, function(x){
  DSI::datashield.assign.expr(conns = conns, symbol = paste0("gds", x, "_object"),
                            expr = as.symbol(paste0("as.resource.object(chr", x, ")")))
})
```

Now we have resolved the resources named `chrXX` into our remote R sessions. The objects retrieved have been assigned into variables named `gdsXX_object`. We can check the process was successful as we did before.

```{r multi_cohort_check_class}
ds.class("gds1_object")
```

### Assign the phenotypes {#assign-the-phenotypes-1}

The objects we have loaded into our remote sessions are VCF files that contain genomic information of the individuals. To perform a GWAS this information has to be related to some phenotypes to extract relationships. Therefore, we need to load the phenotypes into the remote sessions. The phenotypes information is a table that contains the individuals as rows and phenotypes as columns. In this use case, we will use a resource (as with the VCF files) to load the phenotypes table into the remote sessions.

As with the VCF resources, here we load a different resource to each cohort, as it is expected that each cohort has only the phenotypes information regarding their individuals, therefore different tables. Note that we are assigning the resource to the same variable at each server (`pheno`), so we only need one function call to resolve all the resources together.

```{r multi_cohort_assign_covariates_table}
# Cohort 1 phenotypes table
DSI::datashield.assign.resource(conns[1], "pheno", "GWAS.ega_phenotypes_1")

# Cohort 2 phenotypes table
DSI::datashield.assign.resource(conns[2], "pheno", "GWAS.ega_phenotypes_2")

# Cohort 3 phenotypes table
DSI::datashield.assign.resource(conns[3], "pheno", "GWAS.ega_phenotypes_3")

# Resolve phenotypes table
DSI::datashield.assign.expr(conns = conns, symbol = "pheno_object",
                            expr = quote(as.resource.data.frame(pheno)))
```

We can follow the same analogy as before to know that we have assigned the phenotypes table to a variable called `pheno_object` on the remote R session.

```{r multi_cohort_check_class_table}
ds.class("pheno_object")
```

We can also check the column names to see which information is present on the table.

```{r}
ds.colnames("pheno_object")[[1]]
```

### Merge VCF (genotype) and phenotype information {#merge-vcf-genotype-and-phenotype-information}

Arrived at this point, we have 21 VCF objects at each cohort R session (each one corresponds to a chromosome) and a phenotypes table. The next step is merging each of the VCF objects with the phenotypes table. The same procedure as the [single cohort](#vcf_merge) can be applied to extract the arguments required.

With all this information we can now merge the phenotypes and VCF objects into a type of object named GenotypeData. We will use the `ds.GenotypeData` function.

```{r multi_cohort_create_genoData, message=FALSE, warning=FALSE, results=FALSE}
lapply(1:21, function(x){
  ds.GenotypeData(x=paste0('gds', x,'_object'), covars = 'pheno_object', 
                  columnId = "subject_id", sexId = "sex",
                  male_encoding = "male", female_encoding = "female",
                  case_control_column = "diabetes_diagnosed_doctor", 
                  case = "Yes", control = "No",
                  newobj.name = paste0('gds.Data', x), datasources = conns)
})
```

The objects we just created are named `gds.DataXX` on the remote session. Now we are ready to perform a GWAS analysis. We will use the same formula as the single cohort use case to be able to compare the results later:

```{r eval=F}
diabetes_diagnosed_doctor ~ sex + hdl_cholesterol
```

### Performing a meta - GWAS {#performing-the-gwas-1}

We now proceed to perform the GWAS analysis.

```{r multi_cohort_GWAS, message=FALSE, warning=FALSE}
results <- ds.metaGWAS(genoData = paste0("gds.Data", 1:21), 
                       model = diabetes_diagnosed_doctor ~ sex + hdl_cholesterol)
```

And we can see the results for each cohort.

::: {#cohort-results .tab}
<button class="tablinks" id="gwas_results_1" onclick="unrolltab(event, 'cohort-results', 'Cohort1')">Cohort 1</button>
<button class="tablinks" onclick="unrolltab(event, 'cohort-results', 'Cohort2')">Cohort 2</button>
<button class="tablinks" onclick="unrolltab(event, 'cohort-results', 'Cohort3')">Cohort 3</button>
::: {#Cohort1 .tabcontent}
#### ⠀ {-}
```{r message=FALSE, warning=FALSE, echo=FALSE}
results[[1]]
```
:::
::: {#Cohort2 .tabcontent}
#### ⠀ {-}
```{r message=FALSE, warning=FALSE, echo=FALSE}
results[[2]]
```
:::
::: {#Cohort3 .tabcontent}
#### ⠀ {-}
```{r message=FALSE, warning=FALSE, echo=FALSE}
results[[3]]
```
:::
:::

### GWAS Plots

We can display the results of the GWAS using a Manhattan plot for each cohort.

::: {#gwas-results .tab}
<button class="tablinks" id="gwas_plot_1" onclick="unrolltab(event, 'gwas-results', 'Cohort1plot')">Cohort 1</button>
<button class="tablinks" onclick="unrolltab(event, 'gwas-results', 'Cohort2plot')">Cohort 2</button>
<button class="tablinks" onclick="unrolltab(event, 'gwas-results', 'Cohort3plot')">Cohort 3</button>
::: {#Cohort1plot .tabcontent}
#### ⠀ {-}
```{r multiCohortManhattanPlot, message=FALSE, warning=FALSE, fig.cap="Manhattan plot of the Cohort 1.", fig.align='center'}
manhattan(results[[1]])
```
:::
::: {#Cohort2plot .tabcontent}
#### ⠀ {-}
```{r multiCohortManhattanPlot2, message=FALSE, warning=FALSE, fig.cap="Manhattan plot of the Cohort 1.", fig.align='center'}
manhattan(results[[2]])
```
:::
::: {#Cohort3plot .tabcontent}
#### ⠀ {-}
```{r multiCohortManhattanPlot3, message=FALSE, warning=FALSE, fig.cap="Manhattan plot of the Cohort 1.", fig.align='center'}
manhattan(results[[3]])
```
:::
:::

### Meta-level quality control

Up to this point we have collected the aggregated statistics from each cohort and we have visualized them. Before meta-analyzing this statistics we have to perform some quality control to make sure there are no major issues. There are three different methods bundled in `dsOmicsClient` to perform such task:

-   **EAF Plot:** Plotting the reported EAFs against a reference set, such as from the HapMap or 1000 Genomes projects, or from one specific study, can help visualize patterns that pinpoint strand issues, allele miscoding or the inclusion of individuals whose self-reported ancestry did not match their genetic ancestry.
-   **P-Z Plot:** Plot to reveal issues with beta estimates, standard errors and P values. The plots compare P values reported in the association GWAS with P values calculated from Z-statistics (P.ztest) derived from the reported beta and standard error. A study with no issues should show perfect concordance. It will generate a plot per study, where concordance of all the study SNPs will be displayed.
-   **SE-N Plot:** Plot to reveal issues with trait transformations. A collection of studies with no issues will fall on a line.

If any of these QC raises some inconsistencies, please contact the correspondent study analyst.

#### EAF Plot

For this plot we are comparing the estimated allele frequencies to a reference set, so the first step is to get ourselves a reference set. For this example we will be using the `ALL.wgs.phase1_release_v3.20101123` reference set. We will download it and load it into the client R session.

```{r download_reference}
reference <- readr::read_tsv("https://homepages.uni-regensburg.de/~wit59712/easyqc/exomechip/ALL.wgs.phase1_release_v3.20101123.snps_indels_sv.sites.EUR_AF.txt.exm.tab.sexChr.DI.txt.GZ")
reference
```

Now we just use the function `eafPlot` and we pass to it the GWAS results and the reference set.

```{r eafPlot, fig.cap="EAF Plot.", fig.align='center'}
eafPlot(x = results, reference = reference, rs_reference = "Rs", freq_reference = "Freq")
```

The obtained results are the expected, which is a linear correlation of slope one. This indicates the alleles are correctly encoded. For further explanation on how to assess the results produced by this plot, please refer to the Figure 4 of @winkler2014quality.

#### P-Z Plot

This plot will assess the issues with beta estimates, standard errors and P values. Here we will only need the results from the `ds.GWAS` function and pass them to the function `pzPlot`.

```{r pzplot, fig.cap="P-Z Plot.", fig.align='center'}
pzPlot(results)
```

Please note that all the SNPs are plotted, for that reason there may be some performance issues if there are many SNPs to be plotted.

A dataset with no issues will show perfect concordance. For further details please refer to the Figure 3 of @winkler2014quality.

#### SE-N Plot

Finally, we will assess issues with trait transformations. For this we will only need the results from the `ds.GWAS` function and pass them to the function `seNPlot`.

```{r senplot, fig.cap="SE-N Plot.", fig.align='center'}
seNPlot(results)
```

If all the study points fall on a line, no issues are present. For further detail please refer to the Figure 2 of @winkler2014quality.

### Meta-analysis

Given no problems have been detected on the meta-level QC, we will proceed. Up to this point, we have obtained association results for each cohort on the study. The next step is to combine this information using meta-analysis methods to derive a pooled estimate. Each researcher might have an already built pipeline to do so, or a preferred method; nevertheless, we included a couple methods inside `dsOmicsClient`. They are the following:

-   Meta-analysis of p-values: Using the sum of logs method (Fisher's method).
-   Meta-analysis of beta values: Using a fixed-effects model. Methodology extracted and adapted from @betameta.

#### Assessment of the meta-analysis methods

Previously, we have calculated the same GWAS analysis both using all the individuals and a simulated three-cohort scenario. This gives us the ability to assess how good or bad are the different meta-analysis methods; to do so, we will compare both meta-analysis to the complete data, the evaluation method will be counting the number of top hits that match, more specifically we will search for matches on the top twenty hits.

We apply both methods to the multi-cohort use case results:

```{r meta_fitting}
meta_pvalues <- metaPvalues(results)
meta_bvalues <- metaBetaValues(results)
```

We can now compare the 20 top hits from the complete data (previously stored on the variable `results_single`) to the 20 top hits yielded by both meta-analysis methodologies.

```{r meta_compare}
# Extract 20 top hits for all three cases
  # All individuals
top_20_complete <- results_single %>% arrange(p.value) %>% head(20)
  # Pvalue meta-analysis
top_20_pval <- meta_pvalues %>% arrange(p.meta) %>% head(20)
  # Beta meta-analysis
top_20_beta <- meta_bvalues %>% arrange(pval) %>% head(20)

# Number of hits shared by all individuals case and beta meta-analysis
sum(top_20_complete$rs %in% top_20_beta$rs)
# Number of hits shared by all individuals case and pvalue meta-analysis
sum(top_20_complete$rs %in% top_20_pval$rs)
```

The meta-analysis using beta values recovers a higher amount of top SNPs, therefore it can be considerate a more powerful method for GWAS meta-analyses.

#### Visualizing the results of the meta-analysis

We can use the manhattan plot and locus zoom to visualize the results of the meta-analysis as we visualized the single cohorts before. To help assess the meta-analysis behaviour, we will plot together the meta-analysis results and the complete data results.

##### Manhatan plot

::: {#manhattan-plots .tab}
<button class="tablinks" id = "manhattan-plots-tab" onclick="unrolltab(event, 'manhattan-plots', 'meta-analysis-gwas')">Meta-analysis</button>
<button class="tablinks" onclick="unrolltab(event, 'manhattan-plots', 'common-truth')">Complete data</button>
::: {#meta-analysis-gwas .tabcontent}
###### ⠀ {-}
```{r message=FALSE, warning=FALSE, fig.cap="Manhattan plot of the meta-analysis results."}
manhattan(meta_bvalues)
```
:::
::: {#common-truth .tabcontent}
###### ⠀ {-}
```{r message=FALSE, warning=FALSE, fig.cap="Manhattan plot of the complete data."}
manhattan(results_single)
```
:::
:::

##### LocusZoom 

::: {#locuszoom-plots .tab}
<button class="tablinks" id = "locuszoom-plots-tabs" onclick="unrolltab(event, 'locuszoom-plots', 'meta-analysis-gwas-locus')">Meta-analysis</button>
<button class="tablinks" onclick="unrolltab(event, 'locuszoom-plots', 'common-truth-locus')">Complete data</button>
::: {#meta-analysis-gwas-locus .tabcontent}
###### ⠀ {-}
```{r message=FALSE, warning=FALSE, fig.cap="LocusZoom plot of the meta-analysis results."}
LocusZoom(meta_bvalues, pvalue = "p.F", use_biomaRt = FALSE)
```
:::
::: {#common-truth-locus .tabcontent}
###### ⠀ {-}
```{r message=FALSE, warning=FALSE, fig.cap="LocusZoom plot of the complete data."}
LocusZoom(results_single, use_biomaRt = FALSE)
```
:::
:::

#### Meta-analysis versus pooled linear models

The `dsOmicsClient` package also bundles a function to fit pooled generalized linear models (GLM) on single (or multiple) SNPs. On this section we will compare the results of the meta-analysis to the pooled GLM models to see which method is more accurate. The meta-analysis method will be the beta values (fixed-effects model).

The study methodology will be similar to the one we just performed. The top 20 hits yielded by the meta-analysis will be selected, those SNPs will be studied using the pooled GLM function. Both results will be compared to the complete data.

We aim to replicate a real scenario with this study, typically there is no access to the complete data (if so there is no point on performing meta-analysis on synthetic multi-cohorts), therefore we simulate the discovery of SNPs of interest via meta-analysis, then we want to assess if studying individually those SNPs using pooled GLM will put us closer to the results yielded by having the complete data.

We have already calculated the top 20 SNPs discovered by the beta meta-analysis.

```{r}
top_20_beta
```

Next, we have to fit pooled GLM using the `ds.glmSNP` function, obviously we have to fit the same model that we did on the GWAS (`Diabetes.diagnosed.by.doctor ~ sex + HDL.cholesterol`), otherwise the results will not be consistent. 

The `ds.glmSNP` function is an extension of the `dsBaseClient::ds.glm` function, therefore it offers pooled analysis capabilities and disclosure controls.

Remember that we have the genotype data separated by chromosome, following that we will construct the GLM calls as follows:

```{r pooled_analysis, message=FALSE, warning=FALSE, results=FALSE}
s <- lapply(1:nrow(top_20_beta), function(x){
  tryCatch({
    ds.glmSNP(snps.fit = top_20_beta[x, 1], 
              model = diabetes_diagnosed_doctor ~ sex + hdl_cholesterol, 
              genoData = paste0("gds.Data", top_20_beta[x, 2]))
  }, error = function(w){NULL})
})
# Simple data cleaning and column name changes
ss <- data.frame(do.call(rbind, s))
ss <- ss %>% rownames_to_column("rs")
pooled <- ss %>% dplyr::rename(Est.pooled = Estimate, 
                               SE.pooled = Std..Error, 
                               pval.pooled = p.value) %>% 
  dplyr::select(-c(n, p.adj))
```

<!-- ```{r} -->
<!-- # ds.glmSNP(snps.fit = unlist(top_20_beta[3:5, 1]), model = diabetes_diagnosed_doctor ~ sex + hdl_cholesterol, genoData = paste0("gds.Data", unlist(top_20_beta[3:5, 2])), mc.cores = 3) -->
<!-- ``` -->

We now extract the results of interest from the meta-analysis and the complete data.

```{r}
# Get data from all individuals study
original <- results_single %>% dplyr::rename(pval.original = p.value, 
                                             Est.original = Est, 
                                             SE.original = Est.SE) %>%
  dplyr::select(c(rs, Est.original, SE.original, pval.original))
# Arrange dadta from beta meta-analysis
beta <- top_20_beta %>% dplyr::rename(pval.beta = pval, 
                                      Est.beta = b.F, 
                                      SE.beta = se.F) %>%
  dplyr::select(c(rs, Est.beta, SE.beta, pval.beta))
# Merge all data on a single table
total <- Reduce(function(x,y){inner_join(x,y, by = "rs")}, 
                list(original, pooled, beta))
```

With all the information gathered we can visualize the results on the Table <a href="#tab:tab4">4</a>.

<caption>

[Table 4: Beta values, standard errors and p-values yielded by the three methods: GWAS of all individuals, meta-analysis of synthetic cohorts, pooled analysis of synthetic cohorts.]{#tab:tab4 style="font-size:8pt"}

</caption>

```{r f, echo=F}
library(gt)
total %>% gt() %>% tab_spanner(label = 'Beta', columns = c(Est.original, Est.pooled, Est.beta)) %>% tab_spanner(label = 'SE', columns = c(SE.original, SE.pooled, SE.beta)) %>% tab_spanner(label = 'P-Value', columns = c(pval.original, pval.pooled, pval.beta)) %>% cols_label(Est.original = "Original", Est.pooled = "Pooled", Est.beta = "Meta", SE.original = "Original", SE.pooled = "Pooled", SE.beta = "Meta", pval.original = "Original", pval.pooled = "Pooled", pval.beta = "Meta", rs = "SNP id") %>% fmt_number(columns = c(Est.original, Est.pooled, Est.beta, SE.original, SE.pooled, SE.beta), decimals = 3) %>% fmt_scientific(columns = c(pval.original, pval.pooled, pval.beta), decimals = 1) %>% tab_options(column_labels.font.weight = "bold") %>% tab_style(style = cell_fill(color = "grey"), locations = list(cells_body(columns = c(SE.original, SE.pooled, SE.beta), rows = c(seq(2,nrow(total),2))))) %>% tab_style(style = cell_fill(color = "lightgray"), locations = list(cells_body(columns = c(SE.original, SE.pooled, SE.beta), rows = c(seq(1,nrow(total),2))))) %>% tab_style(style = cell_borders(sides = "all", color = "lightgrey", style = "solid", weight = px(1)), locations = cells_body(columns = everything(), rows = everything())) %>% tab_style(style = cell_text(color = "red"), locations = list(cells_body(columns = Est.original, rows = Est.original<0))) %>% tab_style(style = cell_text(color = "red"), locations = list(cells_body(columns = Est.beta, rows = Est.beta<0))) %>% tab_style(style = cell_text(color = "red"), locations = list(cells_body(columns = Est.pooled, rows = Est.pooled<0))) %>% tab_options(table.font.size = "10pt")
```

Finally, to conclude this study we can compute the bias and mean squared error (code not shown). The results are shown on the Table <a href="#tab:tab5">5</a>.

```{r echo=F}
# MSE
mse_est_pooled <- mean((total$Est.original - total$Est.pooled)^2)
mse_est_beta <- mean((total$Est.original - total$Est.beta)^2)
```

```{r echo=F}
# Bias
bias_est_pooled <- mean(total$Est.original - total$Est.pooled)
bias_est_beta <- mean(total$Est.original - total$Est.beta)
```

```{r echo=F}
statistics <- data.frame(MSE = c(mse_est_pooled, mse_est_beta), Bias = c(bias_est_pooled, bias_est_beta), stat = c("Beta", "Beta"), var = c("Pooled", "Meta"))
```

<caption>

[Table 5: Mean squared error and bias for the betas from the meta-analysis and pooled analysis compared to the complete data (all individuals).]{#tab:tab5 style="font-size:8pt"}

</caption>

```{r echo=F}
statistics %>% group_by(stat) %>% gt(rowname_col = "var") %>% fmt_scientific(columns = c(MSE, Bias), decimals = 1) %>% tab_options(column_labels.font.weight = "bold") %>% tab_options(table.font.size = "10pt")
```

With this results we can conclude that refining the statistics for the SNPs of interest using pooled GLM is advisable. Therefore the recommended flowchart when performing a GWAS using `dsOmicsClient+DataSHIELD` is the following:

REVISAR ESTOS RESULTADOS

1.  Perform GWAS with `dsOmicsClient::dsGWAS`
2.  Perform meta-analysis on the results with `dsOmicsClient::metaBetaValues`
3.  Extract top hits from the meta-analysis.
4.  Perform pooled GLM on top hits with `dsOmicsClient::ds.glmSNP`

### Ultra fast pooled GWAS analysis {#ultra-fast-gwas}

An alternate methodology to performing a meta analysis is to use the fast GWAS methodology. This method is named after the performance it achieves, however, it does provide further advantages other than computational speed. The main advantage is that it does not compute the results for each cohort to then be meta-analyzed, it actually computes them using a pooled technique that achieves the *exact* same results when all the individuals are together than when they are separated by cohorts. This is of great importance as there is no need to worry about cohort-imbalance, which is usually a problem in multi-cohort meta-analysis studies. The only downside of this method is that it does not yield the same results of a traditional GWAS analysis pipeline, the inacuraccy of the results however is really low, detailed information about that can be found on the [paper that proposes the method](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-166).

The performance of the function can be summarized to be ~45 seconds per 1M of SNPs (statistic extracted using 2.5k individuals divided into three study servers). From our test this performance has hold linear up to 10M SNPs, we did not test any further. The graphic for < 1M SNPs can be found on the following figure.

```{r fastgwasperformance, echo=FALSE, fig.cap="Benhmark of `ds.fastGWAS` function.", out.width="80%", fig.align='center'}
knitr::include_graphics("fig/gwas_benchmark.png")
```

The usage is similar to the meta-GWAS with a couple of added options, feel free to check the documentation with `?ds.fastGWAS` to see information about them.

```{r multi_fast_GWAS, message=FALSE, warning=FALSE}
results_fast <- ds.fastGWAS(genoData = paste0("gds.Data", 1:21), 
                            formula = "diabetes_diagnosed_doctor ~ sex + hdl_cholesterol", 
                            family = "binomial", snpBlock = 5000)
```

```{r}
datashield.logout(conns)
```

#### GWAS Plot

We can display the results of the fast GWAS using a Manhattan plot.


```{r fastManhattanPlot, message=FALSE, warning=FALSE, fig.cap="Manhattan plot of the Cohort 1.", fig.align='center'}
manhattan(results_fast, pvalCol = 4)
```

#### Meta-analysis versus fast GWAS

To finish the GWAS section we can evaluate the results of the beta meta-analysis and the results of the fast GWAS. Both methods will be compared to the ground truth.

As before we can start by seeing the amount of SNPs that both methodologies recover as top hits.

```{r fast_compare}
# Extract 20 top hits for all three cases
  # All individuals
top_20_complete <- results_single %>% arrange(p.value) %>% head(20)
  # Fast GWAS
top_20_fast <- results_fast %>% arrange(p.value) %>% head(20)
  # Beta meta-analysis
top_20_beta <- meta_bvalues %>% arrange(pval) %>% head(20)

# Number of hits shared by all individuals case and beta meta-analysis
sum(top_20_complete$rs %in% top_20_beta$rs)
# Number of hits shared by all individuals case and fast GWAS
sum(top_20_complete$rs %in% top_20_fast$rs)
```
On that regard it seems the meta-analysis is performing better.

We now extract the results of interest from the meta-analysis and the complete data.

```{r}
# Get data from all individuals study
original <- results_single %>% dplyr::rename(pval.original = p.value, 
                                             Est.original = Est, 
                                             SE.original = Est.SE) %>%
  dplyr::select(c(rs, Est.original, SE.original, pval.original))
# Arrange dadta from beta meta-analysis
beta <- top_20_beta %>% dplyr::rename(pval.beta = pval, 
                                      Est.beta = b.F, 
                                      SE.beta = se.F) %>%
  dplyr::select(c(rs, Est.beta, SE.beta, pval.beta))
# Arrange data from fast GWAS
fast <- top_20_fast %>% dplyr::rename(pval.fast = p.value, 
                                      Est.fast = Est, 
                                      SE.fast = Est.SE) %>%
  dplyr::select(c(rs, Est.fast, SE.fast, pval.fast))
# Merge all data on a single table
total <- Reduce(function(x,y){inner_join(x,y, by = "rs")}, 
                list(original, fast, beta))
```

With all the information gathered we can visualize the results on the Table <a href="#tab:tab6">6</a>.

<caption>

[Table 6: Beta values, standard errors and p-values yielded by the three methods: GWAS of all individuals, meta-analysis of synthetic cohorts, fast GWAS.]{#tab:tab6 style="font-size:8pt"}

</caption>

```{r ff, echo=F}
library(gt)
total %>% gt() %>% tab_spanner(label = 'Beta', columns = c(Est.original, Est.fast, Est.beta)) %>% tab_spanner(label = 'SE', columns = c(SE.original, SE.fast, SE.beta)) %>% tab_spanner(label = 'P-Value', columns = c(pval.original, pval.fast, pval.beta)) %>% cols_label(Est.original = "Original", Est.fast = "Fast", Est.beta = "Meta", SE.original = "Original", SE.fast = "Fast", SE.beta = "Meta", pval.original = "Original", pval.fast = "Fast", pval.beta = "Meta", rs = "SNP id") %>% fmt_number(columns = c(Est.original, Est.fast, Est.beta, SE.original, SE.fast, SE.beta), decimals = 3) %>% fmt_scientific(columns = c(pval.original, pval.fast, pval.beta), decimals = 1) %>% tab_options(column_labels.font.weight = "bold") %>% tab_style(style = cell_fill(color = "grey"), locations = list(cells_body(columns = c(SE.original, SE.fast, SE.beta), rows = c(seq(2,nrow(total),2))))) %>% tab_style(style = cell_fill(color = "lightgray"), locations = list(cells_body(columns = c(SE.original, SE.fast, SE.beta), rows = c(seq(1,nrow(total),2))))) %>% tab_style(style = cell_borders(sides = "all", color = "lightgrey", style = "solid", weight = px(1)), locations = cells_body(columns = everything(), rows = everything())) %>% tab_style(style = cell_text(color = "red"), locations = list(cells_body(columns = Est.original, rows = Est.original<0))) %>% tab_style(style = cell_text(color = "red"), locations = list(cells_body(columns = Est.beta, rows = Est.beta<0))) %>% tab_style(style = cell_text(color = "red"), locations = list(cells_body(columns = Est.fast, rows = Est.fast<0))) %>% tab_options(table.font.size = "10pt")
```

Finally, to conclude this study we can compute the bias and mean squared error (code not shown). The results are shown on the Table <a href="#tab:tab7">7</a>.

```{r echo=F}
# MSE
mse_est_fast <- mean((total$Est.original - total$Est.fast)^2)
mse_est_beta <- mean((total$Est.original - total$Est.beta)^2)
```

```{r echo=F}
# Bias
bias_est_fast <- mean(total$Est.original - total$Est.fast)
bias_est_beta <- mean(total$Est.original - total$Est.beta)
```

```{r echo=F}
statistics <- data.frame(MSE = c(mse_est_fast, mse_est_beta), 
                         Bias = c(bias_est_fast, bias_est_beta), 
                         stat = c("Beta", "Beta"), 
                         var = c("Fast", "Meta"))
```

<caption>

[Table 7: Mean squared error and bias for the betas from the meta-analysis and fast GWAS compared to the complete data (all individuals).]{#tab:tab5 style="font-size:8pt"}

</caption>

```{r echo=F}
statistics %>% group_by(stat) %>% gt(rowname_col = "var") %>% fmt_scientific(columns = c(MSE, Bias), decimals = 1) %>% tab_options(column_labels.font.weight = "bold") %>% tab_options(table.font.size = "10pt")
```

On this brief comparison we've seen that the fast GWAS retrieves sensibly less SNPs from the ground truth but it has better performance of bias and MSE. It must be noted that the data used for this GWAS examples does not suffer from any cohort imbalance, so the meta-analysis is expected to yield proper results, on a different environment the fast GWAS is expected to exceed the performance of the meta-analysis in a more remarkable manner.

## Post-omic analysis {#post-omics}

Up to this point we have analyzed the genotype and phenotype data by performing a genome wide association study. We can further study the yielded results by performing an enrichment analysis.

### Enrichment analysis

The GWAS results are a collection of SNPs that displayed a relationship with a given phenotype. Those SNPs may fall inside gene regions, and those genes can be functionally related. Studying this can help researchers understand the underlying biological processes. Those analysis are carried by querying the selected gene to a database, for this example we will be using the [DisGeNET database](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4397996/).

#### Annotation of genes

The first step of the enrichment analysis is to annotate the genes that contain the SNPs of interest yielded by the GWAS. There are many ways to perform this step, we propose to use the `biomaRt` package and retrieve the annotation from the `ensembl` genome browser.

First we select the SNPs of interest. We have established a `p.value` threshold to do so.

```{r snps_of_interest}
snps_of_interest <- results_fast %>% 
  dplyr::arrange(p.value) %>% 
  dplyr::select(chr, pos, rs, p.value) %>% 
  dplyr::filter(p.value < 0.00005) 
```

And with this list of SNPs we can move to the annotation.

```{r annotation_genes}
library(biomaRt)
# Perform ensembl connection
gene.ensembl <- useEnsembl(biomart = "ensembl", 
                           dataset = "hsapiens_gene_ensembl", GRCh = 37)
# Query SNP by SNP
genes_interest <- Reduce(rbind, apply(snps_of_interest, 1, function(x){
  result <- getBM(
    attributes = c('entrezgene_id', 'chromosome_name', 
                   'ensembl_gene_id', 'start_position', 
                   "end_position"), 
    filters = c('start', 'end', 'chromosome_name'), 
    values = list(start = x[2], end = x[2], 
                  chromosome_name = x[1]), 
    mart = gene.ensembl)
}))
```

#### Enrichment analysis query

Having the genes of interest annotated, the final step is to query them to DisGeNET. We will use the function `enrichDGN` from the package `DOSE` for it. This package is part of a large [ecosystem](https://yulab-smu.top/biomedical-knowledge-mining-book/figures/clusterProfiler-diagram.png) of packages dedicated to enrichment analysis, this allows for easy representation of the query results.

```{r enrichment}
library(DOSE)
enrichment <- enrichDGN(unlist(genes_interest$entrezgene_id), 
                        pvalueCutoff = 0.2)
```

#### Enrichment analysis plots

Here we will portray some of the visualizations that can be performed with the query results. For more information and further visualization options please read the [official vignette](https://yulab-smu.top/biomedical-knowledge-mining-book/index.html).

##### Barplot

```{r barplot_enrichment}
library(enrichplot)
barplot(enrichment)
```

##### Dotplot

```{r dotplot_enrichment}
dotplot(enrichment)
```

##### CNET plot

```{r}
library(ggnewscale)
# convert gene ID to Symbol
edox <- setReadable(enrichment, 'org.Hs.eg.db', 'ENTREZID')
cnetplot(edox, foldChange=genes_interest$entrezgene_id)
```

# Polygenic risk scores

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: left;"><p>`r emo::ji("warning")` RESOURCES USED ALONG THIS SECTION</p></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><p>From <a href="https://opal-demo.obiba.org/">https://opal-demo.obiba.org/</a> :</p></td></tr><tr class="even"><td style="text-align: left;"><table><thead><tr class="header"><th><p>STUDY</p></th><th><p>TABLE</p></th><th><p>PROFILE</p></th></tr></thead><tbody><tr class="odd"><td><p>cohort1</p></td><td><p>GWAS.chr{1..21}A</p></td><td><p>omics</p></td></tr><tr
class="odd"><td><p>cohort2</p></td><td><p>GWAS.chr{1..21}B</p></td><td><p>omics</p></td></tr><tr 
class="odd"><td><p>cohort3</p></td><td><p>GWAS.chr{1..21}C</p></td><td><p>omics</p></td></tr><tr 
class="odd"><td><p>cohort1</p></td><td><p>GWAS.ega_phenotypes_1</p></td><td><p>omics</p></td></tr><tr 
class="odd"><td><p>cohort2</p></td><td><p>GWAS.ega_phenotypes_2</p></td><td><p>omics</p></td></tr><tr 
class="odd"><td><p>cohort3</p></td><td><p>GWAS.ega_phenotypes_3</p></td><td><p>omics</p></td></tr><tr 
</tbody></table></td></tr></tbody></table>

## Definition

By checking for specific variants and quantifying them, a researcher can extract the polygenic risk score (PRS) of an individual, which translates to an associated risk of the individual versus a concrete phenotype. A definition of the term reads

> "A weighted sum of the number of risk alleles carried by an individual, where the risk alleles and their weights are defined by the loci and their measured effects as detected by genome wide association studies." (Extracted from @torkamani2018personal)

The use of PRS markers is very popular nowadays and it has been proved to be a good tool to asses associated risks @escott2017polygenic, @forgetta2020development, @kramer2020breast.

When calculating the PRS using DataSHIELD, the actual scores are not returned, as it would not be GDPR compliant to be able to determine the risk of an individual versus a certain disease. The actual results are stored on the servers and optionally can be merged to the phenotypes table. This allows further study of the PRS using summaries or fitting pooled GLM models to assess relationships between phenotypes and PRS scores.

## Study configuration

The PRS use case will be set up as a multi-cohort, using the same dataset as the multi-cohort GWAS (same VCF resources). A single cohort PRS could be performed analogously using the single cohort example of the GWAS.

```{r prsCohortImage, echo=FALSE, fig.cap="Proposed infrastructure to perform PRS studies.", fig.align='center'}
knitr::include_graphics("fig/prs.png")
```

## Source of polygenic scores

There is a public repository of polygenic scores available at https://www.pgscatalog.org/, on this website there are 2155 different polygenic scores (January 2022) that have been extracted from curated literature. All those scores refer to 526 different traits. Due the relevance of this project, we made sure to include a way of sourcing it's contents automatically.

There are two ways of stating the SNPs of interest and their weights in order to calculate the PRS.

-   Provide a [PGS Catalog](https://www.pgscatalog.org/browse/scores/) 'Polygenic Score ID & Name'. If this option is in use, the SNPs and beta weights will be downloaded from the PGS Catalog and will be used to calculate the PRS. (Example: `PGS000008`)

-   Providing a `prs_table` (SNPs of interest) table. The `prs_table` table has to have a defined structure and column names in order to be understood by this function. This table can be formulated using two schemas:

    -   Scheme 1: Provide SNP positions. Use the column names: `chr_name`, `chr_position`, `effect_allele`, `reference_allele`, `effect_weight`.

    | chr_name | chr_position | effect_allele | reference_allele | effect_weight |
    |----------|--------------|---------------|------------------|---------------|
    | 1        | 100880328    | T             | A                | 0.0373        |
    | 1        | 121287994    | G             | A                | -0.0673       |
    | 6        | 152023191    | A             | G                | 0.0626        |
    | ...      | ...          | ...           | ...              | ...           |

    -   Scheme 2: Provide SNP id's. Use the column names: `rsID`, `effect_allele`, `reference_allele`, `effect_weight`.

    | rdID       | effect_allele | reference_allele | effect_weight |
    |------------|---------------|------------------|---------------|
    | rs11206510 | T             | C                | 0.0769        |
    | rs4773144  | G             | A                | 0.0676        |
    | rs17514846 | A             | C                | 0.0487        |
    | ...        | ...           | ...              | ...           |

The `effect_weight` have to be the betas (log(OR)).

Please note when using a custom `prs_table` table that it is much faster to use the Schema 1, as the subset of the VCF files is miles faster to do using chromosome name and positions rather than SNP id's.

## Connection to the Opal server {#connection-to-the-opal-server-2}

We have to create an Opal connection object to the cohort server. We do that using the following functions.

```{r prs_ds_login, message=FALSE, warning=FALSE}
require('DSI')
require('DSOpal')
require('dsBaseClient')
require('dsOmicsClient')

builder <- DSI::newDSLoginBuilder()
builder$append(server = "cohort1", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
builder$append(server = "cohort2", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
builder$append(server = "cohort3", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
logindata <- builder$build()
conns <- DSI::datashield.login(logins = logindata)
```

## Assign the VCF resources

We assign the VCF and phenotypes resources.

```{r prs_assign_resources, message=FALSE, warning=FALSE, results=FALSE}
# Cohort 1 resources
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns[1], paste0("chr", x), paste0("GWAS.chr", x,"A"))
  })
DSI::datashield.assign.resource(conns[1], "phenotypes_resource", "GWAS.ega_phenotypes_1")

# Cohort 2 resources
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns[2], paste0("chr", x), paste0("GWAS.chr", x,"B"))
  })
DSI::datashield.assign.resource(conns[2], "phenotypes_resource", "GWAS.ega_phenotypes_2")

# Cohort 3 resources
lapply(1:21, function(x){
  DSI::datashield.assign.resource(conns[3], paste0("chr", x), paste0("GWAS.chr", x,"C"))
  })
DSI::datashield.assign.resource(conns[3], "phenotypes_resource", "GWAS.ega_phenotypes_3")
```

```{r prs_resolve_resources, message=FALSE, warning=FALSE, results=FALSE}
DSI::datashield.assign.expr(conns = conns, symbol = "phenotypes",
                            expr = as.symbol("as.resource.data.frame(phenotypes_resource)"))
```

There is one crucial difference between this analysis and the GWAS, here we don't need to resolve the resources. This is for memory efficiency purposes. When we calculate a PRS, we are only interested in a small selection of SNPs, for that reason the (potentially) huge VCF files will be trimmed before being resolved, so only the relevant SNPs are loaded in the memory. For that reason the resolving of the resources is delegated to the `ds.PRS` function, which will perform this trimming according to the SNPs of interest yielded by the PGS catalog query or the `prs_table` table.

## Calculate the PRS

The PRS results will be added to the phenotypes table to be later studied using a pooled GLM. To do that, the following arguments of the function `ds.PRS` will be used:

-   `table`: Name of the table where the results will be merged.
-   `table_id_column`: Number of the column in the `table` table that contains the individuals ID to merge the results from the PRS.
-   `table_prs_name`: Name to append to the PRS results. It will take the structure `prs_table_prs_name` and `prs_nw_table_prs_name`.

### PGS Catalog Example

For this example we will calculate the PRS associated to the trait 'HDL Cholesterol' and 'Thyroid cancer', which corresponds to the PGS ID [PGS000660](https://www.pgscatalog.org/score/PGS000660/) and [PGS000636](https://www.pgscatalog.org/score/PGS000636/)

```{r prs_pgs, warning=FALSE}
resources <- paste0("chr", 1:21)
names(resources) <- paste0("chr", 1:21)
resources <- as.list(resources)
# HDL cholesterol
ds.PRS(resources = resources, pgs_id = "PGS000660", 
       table = "phenotypes", table_id_column = "subject_id")
# Thyroid cancer
ds.PRS(resources = resources, pgs_id = "PGS000636", 
       table = "phenotypes", table_id_column = "subject_id")
```

We can check that the results have been correctly added to the `phenotypes` table.

```{r}
tail(ds.colnames('phenotypes')[[1]])
```

### Custom `prs_table` example

Here we will illustrate a use case with a custom `prs_table`, please note that the proposed SNPs of interest and betas are totally arbitrary.

We will first assemble the `prs_table` table following the indications found on the Details section of `?ds.PRS` (Schema 1).

```{r prs_table}
prs_table <- data.frame(chr_name = c(9, 9, 9, 9, 1, 1, 2, 2),
                  chr_position = c(177034, 161674, 140859, 119681, 
                                   60351, 825410, 154629, 145710),
                  effect_allele = c("T", "C", "G", "C", "G", "G", "T", "A"),
                  reference_allele = c("G", "T", "A", "T", "A", "A", "G", "G"),
                  effect_weight = c(0.5, 0.2, 0.1, 0.2, 0.1, 0.3, 0.1, 0.8))
```

Now we can pass the custom `prs_table` to the PRS function to retrieve the aggregated results.

```{r prs_prs_table, warning=FALSE}
resources <- paste0("chr", 1:21)
names(resources) <- paste0("chr", 1:21)
resources <- as.list(resources)
ds.PRS(resources = resources, prs_table = prs_table, 
       table = "phenotypes", table_id_column = "subject_id", 
       table_prs_name = "custom_prs_table_results")
```

## Study of the PRS results

We can fit pooled GLM models using the function `ds.glm`. In this use case we will fit a model to relate the `HDL.cholesterol` to `prs_PGS000660` adjusted by `sex`. The same will be done with the `prs_PGS000636`.

```{r}
ds.glm(formula = "hdl_cholesterol ~ prs_PGS000660 + sex", 
       family = "gaussian", data = "phenotypes")$coefficients
ds.glm(formula = "hdl_cholesterol ~ prs_PGS000636 + sex", 
       family = "gaussian", data = "phenotypes")$coefficients
```

```{r}
datashield.logout(conns)
```

<!--chapter:end:04-gwas_analysis.Rmd-->

# Differential gene expression (DGE) analysis

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: left;"><p>`r emo::ji("warning")` RESOURCES USED ALONG THIS SECTION</p></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><p>From <a href="https://opal-demo.obiba.org/">https://opal-demo.obiba.org/</a> :</p></td></tr><tr class="even"><td style="text-align: left;"><table><thead><tr class="header"><th><p>STUDY</p></th><th><p>TABLE</p></th><th><p>PROFILE</p></th></tr></thead><tbody><tr class="odd"><td><p>cohort1</p></td><td><p>OMICS.tcga_liver</p></td><td><p>omics</p></td></tr><tr 
</tbody></table></td></tr></tbody></table>

In this section we will illustrate how to perform transcriptomic data analysis using data from [TCGA project](https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga) (section \@ref(TCGALiverdatadescription)). We have uploaded to the demo Opal server a resource called `tcga_liver` whose URL is <http://duffel.rail.bio/recount/TCGA/rse_gene_liver.Rdata> which is available through the [recount project](https://jhubiostatistics.shinyapps.io/recount/). The resource used on this section contains a `RangedSummarizedExperiment`with the RNAseq profiling of liver cancer data from TCGA.

The resource is located inside the `OMICS` project. Some summaries of the dataset are the following:

|                               | TCGA Liver data |
|-------------------------------|-----------------|
| **Number of individuals**     |    424          |
| **Number of genes**           | 58,037          |
| **Number of covariate fields**|    864          |

The structure used is illustrated on the following figure.

```{r dgeProposal, echo=FALSE, fig.cap="Proposed infrastructure to perform DGE studies.", fig.align='center'}
knitr::include_graphics("fig/dge_structure.png")
```

We illustrate a differential expression analysis to compare RNAseq profiling of women vs men (variable `gdc_cases.demographic.gender`). The DGE analysis is normally performed using `r Biocpkg("limma")` package. In that case, as we are analyzing RNA-seq data, `limma + voom` method will be required.

The following use cases will be illustrated:

- DGE analysis
- DGE analysis adjusting for surrogate variables

## Connection to the Opal server

We have to create an Opal connection object to the cohort server. We do that using the following functions.

```{r dge_ds_login, message=FALSE, warning=FALSE}
require('DSI')
require('DSOpal')
require('dsBaseClient')
require('dsOmicsClient')

builder <- DSI::newDSLoginBuilder()
builder$append(server = "cohort1", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
logindata <- builder$build()
conns <- DSI::datashield.login(logins = logindata)
```

## Assign the RSE resource

Now that we have created a connection object to the Opal, we have started a new R session on the server, our analysis will take place in this remote session, so we have to load the data into it.

In this use case we will use one resource from the OMICS project hosted on the demo Opal server. This resources correspond to RangedsummarizedExperiment dataset. The names of the resource is `tcga_liver`, we will refer to it using the string `OMICS.tcga_liver`.

```{r dge_load_resource}
DSI::datashield.assign.resource(conns, "rse_resource", "OMICS.tcga_liver")
```

Now we have assigned the resource named `OMICS.tcga_liver` into our remote R session. We have assigned it to a variable called `rse_resource`. To verify this step has been performed correctly, we could use the `ds.class` function to check for their class and that they exist on the remote sessions.

```{r dge_check_resource}
ds.class("rse_resource")
```

We can see that the object `rse_resource` exists in the server.

Finally the resource is resolved to retrieve the data in the remote session.

```{r dge_resolve_resource}
DSI::datashield.assign.expr(conns = conns, symbol = "rse",
                            expr = as.symbol("as.resource.object(rse_resource)"))
```

Now we have resolved the resource named `rse_resource` into our remote R session. The object retrieved has been assigned into the variable named `rse`. We can check the process was successful as we did before.

```{r dge_check_resolved_resource}
ds.class("rse")
```

## Inspect the RSE

The number of features and samples can be inspected with:

```{r dge_check_features_samples}
ds.dim("rse")
```

And the names of the features using the same function used in the case of analyzing an `ExpressionSet`:

```{r dge_names_features}
name.features <- ds.featureNames("rse")
lapply(name.features, head)
```

Also the covariate names can be inspected by:

```{r dge_covariate_names}
name.vars <- ds.featureData("rse")
lapply(name.vars, head, n=15)
```

We can visualize the levels of the variable having gender information that will be our condition (i.e., we are interested in obtaining genes that are differentially expressed between males and females).

```{r dge_levels}
ds.table1D("rse$gdc_cases.demographic.gender")
```

## Pre-processing for RNAseq data

We have implemented a function called `ds.RNAseqPreproc()` to perform RNAseq data pre-processing that includes:

- Transforming data into log2 CPM units
- Filtering lowly-expressed genes
- Data normalization

```{r dge_rna_preproc}
ds.RNAseqPreproc('rse', group = 'gdc_cases.demographic.gender', 
                 newobj.name = 'rse.pre')
```

Note that it is recommended to indicate the grouping variable (i.e., condition). Once data has been pre-processed, we can perform differential expression analysis. Notice how dimensions have changed given the fact that we have removed genes with low expression which are expected to do not be differentially expressed.

```{r dge_comp}
ds.dim('rse')
ds.dim('rse.pre')
```

## DGE analysis

The differential expression analysis in `dsOmicsClient/dsOmics` is implemented in the funcion `ds.limma()`. This functions runs a limma-pipeline for microarray data and for RNAseq data allows:

- oom + limma
- DESeq2
- edgeR

We recommend to use the `voom + limma` pipeline proposed [here](https://f1000research.com/articles/5-1438/v2) given its versatility and that `limma` is much faster than `DESeq2` and `edgeR`. By default, the function considers that data is obtained from a microarray experiment (`type.data = "microarray"`). Therefore, as we are analyzing RNAseq data, we must indicate that `type.data = "RNAse"`.

```{r dge_limma}
ans.gender <- ds.limma(model =  ~ gdc_cases.demographic.gender, 
                       Set = "rse.pre", type.data = "RNAseq")
```

The top differentially expressed genes can be visualized by:

```{r dge_results}
ans.gender
```

We can verify whether the distribution of the observed p-values are the ones we expect in this type of analyses:

```{r dge_verify_results}
hist(ans.gender$cohort1$P.Value, xlab="Raw p-value gender effect",
     main="", las=1, cex.lab=1.5, cex.axis=1.2, col="gray")
```

## Surrogate variable analysis

We can also check whether there is inflation just executing

```{r dge_inflation}
qqplot(ans.gender$cohort1$P.Value)
```

So, in that case, the model needs to remove unwanted variability ($\lambda > 2$). If so, we can use surrogate variable analysis just changing the argument `sva=TRUE`.

```{r dge_limma_sva}
ans.gender.sva <- ds.limma(model =  ~ gdc_cases.demographic.gender, 
                       Set = "rse.pre", type.data = "RNAseq",
                       sva = TRUE)
```

Now the inflation has dramatically been reduced ($\lambda > 1.12$).

```{r dge_new_lambda}
qqplot(ans.gender.sva$cohort1$P.Value)
```

We can add annotation to the output that is available in our RSE object. We can have access to this information by:

```{r dge_info}
ds.fvarLabels('rse.pre')
```

So, we can run:

```{r dge_new_run}
ans.gender.sva <- ds.limma(model =  ~ gdc_cases.demographic.gender, 
                       Set = "rse.pre", type.data = "RNAseq",
                       sva = TRUE, annotCols = c("chromosome"))
```

The results are:

```{r dge_sec_results}
ans.gender.sva
```

The function has another arguments that can be used to fit other type of models:

- `sva`: estimate surrogate variables
- `annotCols`: to add annotation available in the
- `method`: Linear regression (`“ls”`) or robust regression (`“robust”`) used in limma (`lmFit`)
- `robust`: robust method used for outlier sample variances used in `limma` (`eBayes`)
- `normalization`: normalization method used in the `voom` transformation (default `“none”`)
- `voomQualityWeights`: should `voomQualityWeights` function be used instead of `voom`? (default `FALSE`)
- `big`: should `SmartSVA` be used instead of `SVA` (useful for big sample size or when analyzing epigenome data. Default `FALSE`)

We have also implemented two other functions `ds.DESeq2` and `ds.edgeR` that perform DGE analysis using [DESeq2](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) and [edgeR](https://www.bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf) methods. This is the R code used to that purpose:

**To be supplied**

We close the DataSHIELD session by:

```{r}
datashield.logout(conns)
```


<!--chapter:end:05-dge_analysis.Rmd-->

# Epigenome-wide association analysis (EWAS)

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: left;"><p>`r emo::ji("warning")` RESOURCES USED ALONG THIS SECTION</p></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><p>From <a href="https://opal-demo.obiba.org/">https://opal-demo.obiba.org/</a> :</p></td></tr><tr class="even"><td style="text-align: left;"><table><thead><tr class="header"><th><p>STUDY</p></th><th><p>TABLE</p></th><th><p>PROFILE</p></th></tr></thead><tbody><tr class="odd"><td><p>cohort1</p></td><td><p>OMICS.GSE66351_1</p></td><td><p>omics</p></td></tr><tr 
class="odd"><td><p>cohort2</p></td><td><p>OMICS.GSE66351_2</p></td><td><p>omics</p></td></tr><tr 
</tbody></table></td></tr></tbody></table>

In this section we will illustrate how to perform an epigenome-wide association analysis (EWAS) using methylation data. EWAS requires basically the same statistical methods as those used in DGE. It should be noticed that the **pooled analysis** we are going to illustrate here can also be performed with transcriptomic data, however the data needs to be harmonized beforehand to ensure each study has the same range values. For EWAS where methylation is measured using beta values (e.g CpG data are in the range 0-1) this is not a problem. In any case, adopting the **meta-analysis** approach could be a safe option without the need of harmonization. 

Moreover, we encourage to perform **pooled analysis** only on the significant hits obtained by the **meta-analysis**, since it is a much slower methodology.

The data used in this section has been downloaded from [GEO](https://www.ncbi.nlm.nih.gov/geo/) (accession number GSE66351) which contains DNA methylation profiling (Illumina 450K array) (section \@ref(GSE66351description)). Data corresponds to CpGs beta values measured in the superior temporal gyrus and prefrontal cortex brain regions of patients with Alzheimer's. 

This kind of data is encapsulated on a type of R object called `ExpressionSet`, this objects are part of the [BioConductor project](https://www.bioconductor.org/) and are meant to contain different sources of genomic data, alongside the genomic data they can also contain the phenotypes and metadata associated to a study. Researchers who are not familiar with `ExpressionSet` can find further information [here](https://www.bioconductor.org/packages/release/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf).

The data that we will be using along this section is an `ExpressionSet` objects. Notice that genomic data is encoded as beta-values that ensure data harmonization across studies.

In order to illustrate how to perform data analyses using federated data, we have split the data into two synthetic cohorts (split by individuals). We have created two resources on the demo Opal server called `GSE66351_1` and `GSE66351_2` respectively. They can be found inside the `OMICS` project. Some summaries of the datasets are the following:

|                               | Cohort 1 | Cohort 2 |   Total |
|-------------------------------|---------:|---------:|--------:|
| Number of CpGs                |  481,868 |  481,868 | 481,868 |
| Number of individuals         |      100 |       90 |     190 |
| Number of covariates          |       49 |       49 |      49 |
| Number of annotation features |       37 |       37 |      37 |

The structure used is illustrated on the following figure.

```{r ewasProposal, echo=FALSE, fig.cap="Proposed infrastructure to perform EWAS studies.", fig.align='center'}
knitr::include_graphics("fig/ewas_structure.png")
```

The data analyst corresponds to the “RStudio” session, which through DataSHIELD Interface (DSI) connects with the Opal server. The Opal servers contain a resource that correspond to the GEO:GSE66351 `ExpressionSet` (subseted by individuals).

We will illustrate the following use cases:

- Single CpG pooled analysis
- Multiple CpGs pooled analysis
- Full genome meta-analysis
- Full genome meta-analysis adjusting for surrogate variables

## Initial steps for all use cases

### Connection to the Opal server

We have to create an Opal connection object to the different cohorts server. We do that using the following functions.

```{r ewas_ds_login, message=FALSE, warning=FALSE}
require('DSI')
require('DSOpal')
require('dsBaseClient')
require('dsOmicsClient')

builder <- DSI::newDSLoginBuilder()
builder$append(server = "cohort1", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
builder$append(server = "cohort2", url = "https://opal-demo.obiba.org/",
               user =  "dsuser", password = "P@ssw0rd",
               driver = "OpalDriver", profile = "omics")
logindata <- builder$build()
conns <- DSI::datashield.login(logins = logindata)
```

It is important to note that in this use case, we are only using one server (https://opal-demo.obiba.org/), on this server there are all the resources that correspond to the different cohorts. On a more real scenario each one of the `builder$append` instructions would be connecting to a different server.

### Assign the `ExpressionSet` resource

Now that we have created a connection object to the different Opals, we have started two R sessions, our analysis will take place on those remote sessions, so we have to load the data into them.

In this use case we will use 2 different resources from the `OMICS` project hosted on the demo Opal server. The names of the resources are  `GSE66351_X` (where `X` is the cohort identifier `1`/`2`). Following the Opal syntax, we will refer to them using the string `OMICS.GSE66351_X`.

We have to refer specifically to each different server by using `conns[X]`, this allows us to communicate with the server of interest to indicate to it the resource that it has to load.

```{r ewas_load_resource}
# Cohort 1 resource load
DSI::datashield.assign.resource(conns[1], "eSet_resource", "OMICS.GSE66351_1")

# Cohort 2 resource load
DSI::datashield.assign.resource(conns[2], "eSet_resource", "OMICS.GSE66351_2")
```

Now we have assigned all the resources named into our remote R sessions. We have assigned them to the variables called `eSet_resource`. To verify this step has been performed correctly, we can use the `ds.class` function to check for their class and that they exist on the remote sessions.

```{r ewas_check_resource}
ds.class("eSet_resource")
```

We can see that the object `eSet_resource` exists in both servers.

Finally the resource is resolved to retrieve the data in the remote sessions.

```{r ewas_resolve_resource}
DSI::datashield.assign.expr(conns = conns, symbol = "eSet",
                            expr = as.symbol("as.resource.object(eSet_resource)"))
```

Now we have resolved the resource named `eSet_resource` into our remote R session. The object retrieved has been assigned into the variable named `eSet`. We can check the process was successful as we did before.

```{r ewas_check_resolved_resource}
ds.class("eSet")
```

### Inspect the `ExpressionSet` {#ewas-inspect}

Feature names can be returned by:

```{r ewas_features}
fn <- ds.featureNames("eSet")
lapply(fn, head)
```

Experimental phenotypes variables can be obtained by:

```{r ewas_variables}
fn <- ds.varLabels("eSet")
lapply(fn, head)
```

The columns of the annotation can be obtained by:

```{r ewas_annotation}
fn <- ds.fvarLabels("eSet")
lapply(fn, head)
```

## Single CpG pooled analysis

Once the methylation data have been loaded into the opal server, we can perform different type of analyses using functions from the `dsOmicsClient` package. Let us start by illustrating how to analyze a single CpG from two cohorts by using an approach that is mathematically equivalent to placing all individual-level (pooled).

```{r ewas_single_pooled}
ans <- ds.lmFeature(feature = "cg07363416", 
                    model = ~ diagnosis + Sex, 
                    Set = "eSet",
                    datasources = conns)
ans
```

## Multiple CpGs pooled analysis

The same analysis can be performed for multiple features. This process can be parallelized using `mclapply` function from the multicore package (only works on GNU/Linux, not on Windows).

```{r ewas_multiple, eval=FALSE}
ans <- ds.lmFeature(feature = c("cg00000029", "cg00000108", "cg00000109", "cg00000165"),
                    model = ~ diagnosis + Sex, 
                    Set = "eSet",
                    datasources = conns,
                    mc.cores = 20)
```

If the `feature` argument is not supplied, all the features will be analyzed, please note that this process can be extremely slow if there is a huge number of features; for example, on the case we are illustrating we have over 400K features, so this process would take too much time.

If all the features are to be studied, we recommend switching to meta-analysis methods. More information on the next section.

## Full genome meta-analysis

We can adopt another strategy that is to run a `glm` of each feature independently at each study using `limma` package (which is really fast) and then combine the results (i.e. **meta-analysis** approach).

```{r ewas_limma}
ans.limma <- ds.limma(model = ~ diagnosis + Sex,
                      Set = "eSet", 
                      datasources = conns)
```

Then, we can visualize the top genes at each study (i.e server) by:

```{r ewas_limma_top}
lapply(ans.limma, head)
```

The annotation can be added by using the argument `annotCols`. It should be a vector with the columns of the annotation available in the `ExpressionSet` or `RangedSummarizedExperiment` that want to be showed. To obtain the available annotation columns revisit #ewas-inspect.

```{r ewas_limma_annotated}
ans.limma.annot <- ds.limma(model = ~ diagnosis + Sex,
                            Set = "eSet", 
                            annotCols = c("CHR", "UCSC_RefGene_Name"),
                            datasources = conns)
lapply(ans.limma.annot, head)
```

Then, the last step is to meta-analyze the results. Different methods can be used to this end. We have implemented a method that meta-analyze the p-pvalues of each study as follows:

```{r ewas_limma_meta}
ans.meta <- metaPvalues(ans.limma)
ans.meta
```

We can verify that the results are pretty similar to those obtained using pooled analyses. Here we compute the association for the top two CpGs:

```{r ewas_limma_meta_top_pooled}
res <- ds.lmFeature(feature = ans.meta$id[1:2], 
                     model = ~ diagnosis + Sex, 
                     Set = "eSet",
                     datasources = conns)
res
```

We can create a QQ-plot by using the function `qqplot` available in our package.

```{r ewas_limma_qq}
qqplot(ans.meta$p.meta)
```

Here In some cases inflation can be observed, so that, correction for cell-type or surrogate variables must be performed. We describe how we can do that in the next two sections.

## Adjusting for surrogate variables

The vast majority of omic studies require to control for unwanted variability. The surrogate variable analysis (SVA) can address this issue by estimating some hidden covariates that capture differences across individuals due to some artifacts such as batch effects or sample quality among others. The method is implemented in [SVA](https://bioconductor.org/packages/release/bioc/html/sva.html) package.

Performing this type of analysis using the `ds.lmFeature` function is not allowed since estimating SVA would require to implement a non-disclosive method that computes SVA from the different servers. This will be a future topic of the `dsOmicsClient`. For that reason we have to adopt a compromise solution which is to perform the SVA independently at each study. We use the `ds.limma` function to perform the analyses adjusted for SVA at each study.

```{r ewas_limma_sva}
ans.sva <- ds.limma(model = ~ diagnosis + Sex, 
                    Set = "eSet",
                    sva = TRUE, annotCols = c("CHR", "UCSC_RefGene_Name"))
ans.sva
```

Then, data can be combined meta-anlyzed as follows:

```{r ewas_limma_sva_meta}
ans.meta.sv <- metaPvalues(ans.sva)
ans.meta.sv
```

And we can revisit the qqplot:

```{r ewas_limma_sva_meta_qq}
qqplot(ans.meta.sv$p.meta)
```

The DataSHIELD session must be closed by:

```{r}
datashield.logout(conns)
```


<!--chapter:end:06-epi_analysis.Rmd-->

# (PART) Showcase on a real dataset {-}

```{r , TranscriptHELIXsetup_0, include=FALSE}
knitr::opts_chunk$set(comment="", warning=FALSE, message=FALSE, cache=TRUE)
```

# Transcriptomic analysis in the HELIX cohort. {#TranscriptHELIX}

In this section, we will illustrate how to perform **gene expression analysis** using data from the **HELIX project**. Particularly, we will analyse **microarray data** deriving from the _Human Transcriptome Array 2.0_ Affymetrix platform. On these data, we will show how to perform a **differential gene expression analysis** comparing the **transcriptomic profiles** of **boys** and **girls** in the **HELIX cohorts**. 

The **microarray data** to be analysed has been previously **pre-processed** (e.g., normalized, low expression or cross-reactive probes removed, etc.), so, this showcase will be restricted to the analysis part. For that, we will employ the **dsOmicsClient** functions that adapt some of the most important **"limma"** methods for their use in **dataSHIELD**. Please, note that **pre-processing of gene expression data** is also included in **dsOmicsClient** as indicated in our [bookdown](https://github.com/isglobal-brge/OmicSHIELD). For this tutorial, data are hosted in the [Opal BRGE site](https://datashield.isglobal.org/brge/ui/index.html) simulating a **single-site DataSHIELD architecture**, as previously described in the section \@ref(TranscriptomicsHELIXDatadescript).

## Getting started. {#TranscriptHELIXone}

In this section, we will describe how to **configure R and DataSHIELD** with the **needed packages** to carry out proposed analyses in remote. We start by **installing** the *client-side* version of the following **DataSHIELD/Opal** integration packages.

```{r TranscriptHELIXsetup1, eval=FALSE}

install.packages("DSOpal", dependencies=TRUE)
install.packages("DSI", dependencies=TRUE)

```

Make sure you also install the **DataSHIELD** *client-side* version of the package **dsBaseClient**.

```{r TranscriptHELIXsetup2, eval=FALSE}

install.packages("dsBaseClient", 
                 repos = c("http://cran.datashield.org","https://cloud.r-project.org/"),
                 dependencies = TRUE)

```

Then, install the *client-side* version of the **dsOmicsClient** package directly from *GitHub*.

```{r TranscriptHELIXsetup3, eval=FALSE}

install.packages("devtools")
require("devtools")
devtools::install_github("isglobal-brge/dsOmicsClient",ref="master",
                         auth_token = "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",force=TRUE)

```

Once installations are completed, all the packages are **loaded** as usual.

```{r TranscriptHELIXsetup4, echo=TRUE, results="hide", message=FALSE}

require(DSOpal)
require(DSI)
require(dsBaseClient)
require(dsOmicsClient)

# Loading additional required packages (if not installed, you can easly install them using the BiocManager::install() function)
require(clusterProfiler)
require(org.Hs.eg.db)
require(ggplot2)
require(biomaRt)

```

## Data formatting and manipulation in DataSHIELD. {#TranscriptHELIXdatamanip}

In this section, we will cover how to **load** and **inspect** input **microarray data** with **DataSHIELD**. We start by **creating the connection to the opal server** using an user who have **DataSHIELD permissions**.

```{r TranscriptHELIXcreating_conns_login_1, echo=TRUE, results="hide", message=FALSE}

builder <- DSI::newDSLoginBuilder()
builder$append(server = "BIB", url = "https://datashield.isglobal.org/repo",
               user =  "invited", password = "12345678",
               profile = "rock-inma")
builder$append(server = "EDEN", url = "https://datashield.isglobal.org/repo",
               user =  "invited", password = "12345678",
               profile = "rock-inma")
builder$append(server = "KANC", url = "https://datashield.isglobal.org/repo",
               user =  "invited", password = "12345678",
               profile = "rock-inma")
builder$append(server = "MoBA", url = "https://datashield.isglobal.org/repo",
               user =  "invited", password = "12345678",
               profile = "rock-inma")
builder$append(server = "Rhea", url = "https://datashield.isglobal.org/repo",
               user =  "invited", password = "12345678",
               profile = "rock-inma")
builder$append(server = "INMASAB", url = "https://datashield.isglobal.org/repo",
               user =  "invited", password = "12345678",
               profile = "rock-inma")
logindata <- builder$build()
conns <- DSI::datashield.login(logins = logindata)

``` 

Now that we have created a connection object to the Opal, we have started a new R session on the server, and our analysis will take place in this remote session, so we have to **load the data** into it. In this use case, available data are in the form **ExpressionSet** files. **ExpressionSet** is a file-format of the [BioConductor project](https://www.bioconductor.org/) that may contain different sources of **genomic data**. Alongside the **genomic data**, **ExpressionSet** may also contain some **phenotypes** and **metadata** associated to the population. Researchers who are not familiar with **ExpressionSet** can find further information [here](https://www.bioconductor.org/packages/release/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf).

For our showcase, one **ExpressionSet** file per cohort is hosted in the [Opal BRGE site](https://datashield.isglobal.org/brge/ui/index.html) in the form of a **resource**, all organized within the Opal server in a **project** called **"HELIX_omics"**.

For loading these data into the remote **DataSHIELD** session we will use the _DSI::datashield.assign.resource()_ function. This function takes the connections to the server created in the previous code chunk to assign all available **resource objects** from a project in the **Opal** to an **R object** in the **DataSHIELD remote session**. As it can be seen in the code, **resources** in **DataSHIELD** are called in the function following the next structure *"NameOfOpalProject.NameOfResource"*. 

```{r TranscriptHELIXassign_resources_login_2, echo=TRUE, results="hide", message=FALSE}

# We assign microarray data from all cohorts to an object called resource_pos
DSI::datashield.assign.resource(conns[1], "resource_expr", 
                                "HELIX_omics.genexpr_BIB")
DSI::datashield.assign.resource(conns[2], "resource_expr", 
                                "HELIX_omics.genexpr_EDE")
DSI::datashield.assign.resource(conns[3], "resource_expr", 
                                "HELIX_omics.genexpr_KAN")
DSI::datashield.assign.resource(conns[4], "resource_expr", 
                                "HELIX_omics.genexpr_MOB")
DSI::datashield.assign.resource(conns[5], "resource_expr", 
                                "HELIX_omics.genexpr_RHE")
DSI::datashield.assign.resource(conns[6], "resource_expr", 
                                "HELIX_omics.genexpr_SAB")

```

With these instructions, we have assigned the resources into our **remote R** session to a variable called **"resource_expr"**. To verify this step has been performed correctly, we could use the _ds.class()_ function to check for their class and that they exist on the remote session. Then, we have to **resolve the resource** and **retrieve the data in the remote session**. For that, we will use the _DSI::datashield.assign.expr()_ function. 

```{r TranscriptHELIXresolve_resources_login_3, echo=TRUE, results="hide", message=FALSE}

# We resolve the resource
DSI::datashield.assign.expr(conns = conns, symbol = "resource_expr_HELIX",
                       expr = as.symbol("as.resource.object(resource_expr)"))
```

As a result, we will get an **R object** (here named **"resource_expr_HELIX"**) containing the available **"ExpressionSets"** files for cohorts. For created objects, we can extract some useful information including the **class**, and the **name of the genes included in the microarray** and additional **phenotype** data available.

```{r TranscriptHELIX_descriptive_login_4, echo=TRUE, results="hide", message=FALSE}

# Retrieve the class of loaded files:
ds.class("resource_expr_HELIX")

# Get the names of the first features (probes) available for the first cohort:
name.features <- ds.featureNames("resource_expr_HELIX")
lapply(name.features, head)[[1]]

# Get the names of the phenotype data available for the first cohort:
name.phenotypes <- ds.varLabels("resource_expr_HELIX")
lapply(name.phenotypes, head)[[1]]

# Also the annotation information can be inspected by:
name.annot <- ds.fvarLabels("resource_expr_HELIX")
lapply(name.annot, head)[[1]]
# Annotation information refers to additional data available at the feature
# level and that could be added to the summary statistics for a better 
# identification of significant genes.

```

## Differential gene expression analysis. {#TranscriptHELIXDGE}

The **differential expression analysis** in **dsOmicsClient** is implemented in the funcion _ds.limma()_. Although, by default, the function considers that data is obtained from a **microarray experiment** (type.data = "microarray"), it could also be applied to **RNAseq data**.

In this case, since we are interested in evaluating the **gene expression differences** between **boys and girls**, we will run the next model (adjusted by possible confounders such as **age** and **ethnicity**):

```{r TranscriptHELIX_limma_m1, echo=TRUE, message=FALSE}

model.sex <- ds.limma(model =  ~ e3_sex +  age_sample_years + h_ethnicity_cauc, 
                       Set = "resource_expr_HELIX")

```

The top **differentially expressed genes** by cohort can then be visualized by:

```{r exwas_analysis_1, echo=TRUE, message=FALSE}

model.sex

```

We can verify whether the **distribution of the observed p-values** are the ones we would expect in this type of analyses:
  
```{r TranscriptHELIX_limma_m1plot_effects, fig.width=10, fig.height=12}

ggplot(model.sex$BIB, aes(x=P.Value))+
  geom_histogram(color="darkblue", fill="lightblue")+labs(
    title="P-Value histogram plot",x="Raw p-value gender effect", y = "Count")

```
Another functionality of **dsOmicsClient** is that we can add **annotation information** at the probe-level to the output that is obtained with _ds.limma()_. Annotation information will be available as part of the expression set file **"resource_expr_HELIX"** and can be inspected by:

```{r TranscriptHELIX_limma_annot, warning=FALSE, message=FALSE}

# Get annotation information for the first cohort
ds.fvarLabels("resource_expr_HELIX")[[1]]

```

In case we were interested in adding **gene symbol**, **entrezID** and **chromosome number** mapping probes from each output, we can run:

```{r TranscriptHELIX_limma_m2, warning=FALSE, message=FALSE}

model.sex_annot <- ds.limma(model = ~ e3_sex +  age_sample_years + h_ethnicity_cauc, 
                       Set = "resource_expr_HELIX",
                       annotCols = c("GeneSymbol_Affy","seqname",
                                     "EntrezeGeneID_Affy"))

```

The **results** for each of the cohort (ordered by level of significance) can be accessed by:

```{r TranscriptHELIX_limma_m2_results, warning=FALSE, message=FALSE}

model.sex_annot

```

## Surrogate variable analysis.  {#TranscriptHELIXsurrogateAnnot}

We can also check whether there is **inflation** just executing:

```{r TranscriptHELIX_limma_m1qqplot, warning=FALSE, message=FALSE}

qqplot(model.sex$BIB$P.Value)

```

So, in that case, the model does not need to remove unwanted variability (λ<2). If that was not the case, we could use **surrogate variable analysis** just changing the argument _sva=TRUE._. 

The _ds.limma_ function has another arguments that can be used to fit other type of models:

* method: Linear regression (“ls”) or robust regression (“robust”) used in limma (lmFit).
* robust: Logical. Robust method used for outlier sample variances used in limma (eBayes).
* normalization: normalization method used in the voom transformation (default “none”).
* voomQualityWeights: Logical. Should voomQualityWeights function be used instead of voom? (default FALSE)
* big: Logical. If sva was set to TRUE, should SmartSVA be implemented?


Then, data can be combined meta-analysed as follows:

```{r TranscriptHELIX_limma_sva_meta, echo=TRUE, message=FALSE}

metaP.model.sex.annot <- metaPvalues(model.sex_annot)
metaP.model.sex.annot

# Get the number of differentially expressed genes in the meta approach
dim(metaP.model.sex.annot[metaP.model.sex.annot$p.meta<0.05,])

```

## Enrichment analysis of functional annotations. {#TranscriptHELIXenrichment}

Once we have obtained the top **differentially expressed genes** per cohort, we could extract their **gene symbols** or **gene entrez ids** directly from each output dataframe and continue with the **functional annotation analysis** in our local session as usual. To this end, one of the classic approaches is to evaluate whether any information (in the form of annotations) is **over-represented** in the gene list compared to the rest of the genes in the genome. This type of **enrichment** analysis is based on annotating genes with information available in different databases such as [**Gene Ontology**](http://geneontology.org/) or the [**Kyoto Encyclopedia of Genes and Genomes**](https://www.genome.jp/kegg/), and establishing the frequencies of each term in the gene list and the rest of the genome. This allows a statistical test to be applied to determine which functional annotations are significantly enriched in the list.

To extract the list of **top differentially expressed genes** by cohort and perform **enrichment analysis** with **KEGG** we can run the next code lines:

```{r TranscriptHELIX_annot1, warning=FALSE, message=FALSE}

# Get the entrez id for the top differentially expressed genes in each cohort.
get_entrezid <- function(x){ x[(x$adj.P.Val < 0.05),c("id","EntrezeGeneID_Affy")] }
topgenes_by_cohort <- lapply(model.sex_annot,get_entrezid)
length(unlist(lapply(topgenes_by_cohort,function(x) x[,2])))

# Get the entrez id for the top differentially expressed genes in the meta-analysis
# approach
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
filters <- listFilters(ensembl)
attributes <- listAttributes(ensembl)
affy_id <- gsub(x = as.character(metaP.model.sex.annot[metaP.model.sex.annot$p.meta<
                                                         0.05/nrow(metaP.model.sex.annot),1]$id), pattern = "hg.1", "hg")

# Number of probes passing multiple-testing correction in the meta-analysis.
length(affy_id)
# Get the entrez id of the genes mapped by the probes from the previous list.
topgenes_metaP <- getBM(attributes = c("entrezgene_id"),
               filters = "affy_hta_2_0",
               values = affy_id,
               mart = ensembl)
length(topgenes_metaP[,1])

# Functional enrichment analysis with KEGG.

# We will use as reference a list of genes loaded from the DOSE package.
data(geneList, package="DOSE")

# Enrichment for top genes from each cohort
enrichKEGG <- enrichKEGG(gene = unlist(lapply(topgenes_by_cohort,function(x) x[,2])),
                 organism     = 'hsa',
                 pvalueCutoff = 0.1)
head(enrichKEGG)

# Enrichment for top genes from the meta-analysis
enrichKEGG_meta <- enrichKEGG(gene = as.character(topgenes_metaP[,1]),
                 organism     = 'hsa',
                 pvalueCutoff = 0.1)
head(enrichKEGG_meta)

# The pathways can be visualized alongside the genes associated with them:
browseKEGG(enrichKEGG, 'hsa04211')

```

As a result, we identify a list of **325 probes (mapping 287 genes) differentially expressed** between **boys** and **girls** of the **HELIX cohort**, passing multiple-testing correction filter (P-value threshold=1.74e-06). As a proof of the ability of OmicSHIELD to be integrated with other R functionalities and bioconductor utilties, we continued the showcase presenting a functional enrichment analysis (FEA) of results, showing that significant DE genes participate in processes with evident and previously-described **sexual dimorphism** such is the case of **“Longevity regulating pathways” (hsa04211)**.

Once analyses are completed, we proceed to close the **DataSHIELD** session by:

```{r logout}
datashield.logout(conns)
```

<!--chapter:end:07-HELIX_genexpression.Rmd-->

```{r , DNAmsetup_0, include=FALSE}
knitr::opts_chunk$set(comment="", warning=FALSE, message=FALSE, cache=TRUE)
```

# Epigenetic analysis in the HELIX cohort. {#DNAmHELIX}

In this section, we will illustrate how to perform **DNA methylation differential analysis** using real data from the **HELIX project**. Particularly, we will analyse **microarray data** deriving from the _Infinium HumanMethylation450k_ platform of Illumina. On these data, we will show how to perform a **epigenome-wide association analysis (EWAS)** to compare the **DNA methylation profiles** differing between **boys** and **girls** in the **HELIX cohorts**. We will illustrate the following use cases:

* Full genome meta-analysis.
* Full genome meta-analysis adjusting for surrogate variables.

In comparison to **gene expression data**, where data are not always normalized in the same way (especially in the case of **RNAseq data**), when analyzing **EWAS data** one count on normalized Beta or M-Values. This favors the harmonization of the dataset between cohorts, thereby making possible to perform a **pooled analysis** instead of a **meta-analysis** approach.

## Getting started. {#DNAmHELIX_gettingstarted}

In this section, we will describe how to **configure R and DataSHIELD** with the **needed packages** to carry out proposed analyses in remote. We start by **installing** the *client-side* version of the following **DataSHIELD/Opal** integration packages.

```{r DNAmsetup1, eval=FALSE}

install.packages("DSOpal", dependencies=TRUE)
install.packages("DSI", dependencies=TRUE)

```

Make sure you also install the **DataSHIELD** *client-side* version of the package **dsBaseClient**.

```{r DNAmsetup2, eval=FALSE}

install.packages("dsBaseClient", 
        repos = c("http://cran.datashield.org","https://cloud.r-project.org/"),
        dependencies = TRUE)

```

Then, install the *client-side* version of the **dsOmicsClient** package directly from *GitHub*.

```{r DNAmsetup3, eval=FALSE}

install.packages("devtools")
require("devtools")
devtools::install_github("isglobal-brge/dsOmicsClient",ref="master",
                         auth_token = "INSERT_YOUR_GITHUB_TOKEN_HERE")

```

Once installations are completed, all the packages are **loaded** as usual.

```{r DNAmsetup4, echo=TRUE, results="hide", message=FALSE}

require(DSOpal)
require(DSI)
require(dsBaseClient)
require(dsOmicsClient)

# Loading additional required packages (if not installed, you can easly install them using the BiocManager::install() function)
require(clusterProfiler)
require(org.Hs.eg.db)

```

## Data formatting and manipulation in DataSHIELD. {#DNAmHELIX_load}

In this section, we will cover how to **load** and **inspect** input **microarray data** with **DataSHIELD**. We start by **creating the connection to the opal server** using an user who have **DataSHIELD permissions**.

```{r DNAm_login_1, echo=TRUE, results="hide", message=FALSE}

 builder <- DSI::newDSLoginBuilder()
 builder$append(server = "BIB", url = "https://datashield.isglobal.org/repo",
                user =  "invited", password = "12345678"
                , profile = "rock-inma")
 builder$append(server = "EDEN", url = "https://datashield.isglobal.org/repo",
                user =  "invited", password = "12345678",
                profile = "rock-inma")
 builder$append(server = "KANC", url = "https://datashield.isglobal.org/repo",
                user =  "invited", password = "12345678",
                profile = "rock-inma")
 builder$append(server = "MoBA", url = "https://datashield.isglobal.org/repo",
                user =  "invited", password = "12345678",
                profile = "rock-inma")
 builder$append(server = "Rhea", url = "https://datashield.isglobal.org/repo",
                user =  "invited", password = "12345678",
                profile = "rock-inma")
 builder$append(server = "INMASAB", url ="https://datashield.isglobal.org/repo",
                user =  "invited", password = "12345678",
                profile = "rock-inma")
 logindata <- builder$build()
 conns <- DSI::datashield.login(logins = logindata)

``` 
Now that we have created a connection object to the Opal, we have started a new R session on the server, and our analysis will take place in this remote session, so we have to **load the data** into it. In this use case, available data are in the form **GenomicRatioSet**, a extend of the class **SummarizedExperiment** especially designed for DNA methylation data obtained with the _Infinium HumanMethylation450k_ platform and usually analysed with the associated R package [minfi](http://bioconductor.org/packages/release/bioc/html/minfi.html). This type of data usually contain **pre-processed DNA methylation values** at a genome-wide level, in the form of **M or/and Beta values**, together with the associated **genomic coordinates**. As in the case of **ExpressionSet** types, **GenomicRatioSet** can also incorporate **phenotype** and **metadata** information.

For our showcase, one **GenomicRatioSet** file per cohort is hosted in the [Opal BRGE site](https://datashield.isglobal.org/brge/ui/index.html) in the form of a **resource**, all organized within the Opal server in a **project** called **HELIX_omics**.

For loading these data into the remote **DataSHIELD** session we will use the _DSI::datashield.assign.resource()_ function. This function takes the connections to the server created in the previous code chunk to assign all available **resource objects** from a project in the **Opal** to an **R object** in the **DataSHIELD remote session**. As it can be seen in the code, **resources** in **DataSHIELD** are called in the function following the next structure *"NameOfOpalProject.NameOfResource"*. 

```{r DNAmassign_resources_login_2, echo=TRUE, results="hide", message=FALSE}

# We assign post-natal data from all cohorts to an object called resource_pos
DSI::datashield.assign.resource(conns[1], "assinged_resource_DNAm", 
                                "HELIX_omics.methy_BIB")
DSI::datashield.assign.resource(conns[2], "assinged_resource_DNAm", 
                                "HELIX_omics.methy_EDE")
DSI::datashield.assign.resource(conns[3], "assinged_resource_DNAm", 
                                "HELIX_omics.methy_KAN")
DSI::datashield.assign.resource(conns[4], "assinged_resource_DNAm", 
                                "HELIX_omics.methy_MOB")
DSI::datashield.assign.resource(conns[5], "assinged_resource_DNAm", 
                                "HELIX_omics.methy_RHE")
DSI::datashield.assign.resource(conns[6], "assinged_resource_DNAm", 
                                "HELIX_omics.methy_SAB")

```

Then, we have to **resolve the resources** and **retrieve the data in the remote session (server-side)**. For that, we will use the _DSI::datashield.assign.expr()_ function. As a result, we will get an **R object** (here named **"resource_DNAm"**) containing the available **GenomicRatioSet** files for cohorts. For created objects, we can extract some useful information including the **dimension**, **class**, and the **name of the CpGs analysed in the microarray** and additional **phenotype** data available.

```{r DNAmresolve_resources_login_3, echo=TRUE, results="hide", message=FALSE}

# We resolve the resource
DSI::datashield.assign.expr(conns = conns, symbol = "resource_DNAm",
              expr = as.symbol("as.resource.object(assinged_resource_DNAm)"))
ds.dim("resource_DNAm")
ds.class("resource_DNAm")

#The names of the CpGs included in the array can be extracted using
# the same function used for extracting probe names in the case of analyzing 
# an ExpressionSet:
name.features <- ds.featureNames("resource_DNAm")
lapply(name.features, head)[[1]]

#Experimental phenotypes variables can be obtained by:
name.phenotypes <- ds.varLabels("resource_DNAm")
lapply(name.phenotypes, head)[[1]]

#Also the annotation information can be obtained by:
name.annot <- ds.fvarLabels("resource_DNAm")
lapply(name.annot, head)[[1]]

```

## Full genome meta-analysis. {#DNAmHELIX_analysis3}

If we want to perform a quick **full EWAS** analysis in **DataSHIELD** we must run a **meta-analysis** approach (analyzing each cohort separately). For that, we can use the same function than in the showcase of **transcriptomic** analysis (*ds.limma()*).

```{r DNAm_ewas_limma, echo=TRUE, message=FALSE}

meta.model.sex <- ds.limma(model = ~ e3_sex,
                      Set = "resource_DNAm", 
                      datasources = conns)

```

Then, we can visualize the **top significant CpGs** at each study (i.e server) by:

```{r DNAm_ewas_limma_top, echo=TRUE, message=FALSE}

lapply(meta.model.sex, head)

```

As in the case of **gene expression analysis**, annotation columns can be added to the output by using the argument **annotCols**. It should be a vector with the columns of the annotation available in the **GenomeRatioSet** that want to be showed. To obtain the available annotation columns use the function _ds.fvarLabels()_.

```{r DNAm_ewas_limma_annotated, echo=TRUE, message=FALSE}

meta.model.sex.annot <- ds.limma(model = ~ e3_sex,
                Set = "resource_DNAm", 
                annotCols = c("chromosome","start","end","UCSC_RefGene_Name"),
                datasources = conns)
lapply(meta.model.sex.annot, head)


```

Up to this point, we have obtained association results for each cohort on the study. The next step is to **combine** this information using **meta-analysis** methods to derive a **pooled** estimate closest to the common truth. Each researcher might have an already built pipeline to do so, or a preferred method; nevertheless, we included a couple methods inside **dsOmicsClient**. They are the following:

* Meta-analysis of p-values: Using the sum of logs method (**Fisher’s method**). 
* Meta-analysis of beta values: Using a fixed-effects model. Methodology extracted and adapted from [@betameta].

```{r DNAm_ewas_limma_meta, echo=TRUE, message=FALSE}

metaP.model.sex.annot <- metaPvalues(meta.model.sex.annot)
metaP.model.sex.annot

```

We can create a **QQ-plot** by using the function *qqplot()* available in our package.

```{r DNAm_ewas_limma_qq, echo=TRUE, message=FALSE}

qqplot(metaP.model.sex.annot$p.meta)

```

Here, as can be observed, there is no need to remove unwanted variability (λ<2). Nevertheless, we will illustrate how to proceed in case of observing **inflation**.

## Adjusting for surrogate variables. {#DNAmHELIX_analysis4}

The vast majority of omic studies require to control for unwanted variability. The **surrogate variable analysis** can address this issue by estimating some hidden covariates that capture differences across individuals due to some artifacts such as batch effects or sample quality among others. The method is implemented in [SVA](https://bioconductor.org/packages/release/bioc/html/sva.html) package.

Performing this type of analysis using the **ds.lmFeature** function is not allowed since estimating SVA would require to implement a non-disclosive method that computes SVA from the different servers. This will be a future topic of the **dsOmicsClient**. For that reason we have to adopt a compromise solution which is to perform the SVA independently at each study. We use the **ds.limma** function to perform the analyses adjusted for SVA at each study. Especially for the case of **EWAS data** this kind of analysis is important since it is usual to find important sources of unwanted variability affecting the global levels of methylation (e.g., the existence of different white-cell proportions when the sample type under analysis is whole-blood)

```{r DNAm_ewas_limma_sva, echo=TRUE, message=FALSE}

meta.model.sex.annot.sva <- ds.limma(model = ~ e3_sex,
                Set = "resource_DNAm",
                sva = TRUE, 
                annotCols = c("chromosome","start","end","UCSC_RefGene_Name"))
meta.model.sex.annot.sva

```

Then, data can be combined with meta-analysed as follows:

```{r DNAm_ewas_limma_sva_meta, echo=TRUE, message=FALSE}

metaP.model.sex.annot <- metaPvalues(meta.model.sex.annot.sva)
metaP.model.sex.annot

# Get the number of differentially methylated probes in the meta approach
dim(metaP.model.sex.annot[metaP.model.sex.annot$p.meta<0.05,])

# Get the number of differentially expressed genes in the meta approach
# (multiple-testing correction)
dim(metaP.model.sex.annot[metaP.model.sex.annot$p.meta<0.05/nrow(metaP.model.sex.annot),])

```

As a result, from the initial list of almost 300k CpGs, we identify a list of **10,417 DMPs** between **boys** and **girls** of the HELIX cohorts, from which only **3** passed the strict bonferroni **multiple-testing correction**. Of these 3, the **cg12052203 and cg25650246** (mapping the *B3GNT1* and *RFTN1* respectively) have been previously associated with sex methylation differences (http://www.ewascatalog.org).

And we can revisit the **qqplot**:

```{r DNAm_ewas_limma_sva_meta_qq, echo=TRUE, message=FALSE}

qqplot(metaP.model.sex.annot$p.meta)

```

## Enrichment analysis of functional annotations. {#DNAmHELIXenrichment}

Once we have obtained the top **differentially methylated genes** per cohort, we could extract their **gene symbols** or **gene entrez ids** directly from each output dataframe and continue with the **functional annotation analysis (FEA)** in our local session as usual. As presented in the showcase of **gene expression analysis**, we will conduct an **enrichment analysis** with **KEGG**:

```{r DNAm_annot1, warning=FALSE, message=FALSE}

# Get list of significant CpGs (checking the number).
sigCpGs <- as.character(metaP.model.sex.annot[which(
  metaP.model.sex.annot$p.meta < 0.01),"id"][[1]])
length(sigCpGs)

# Load required packages for enrichment analysis with CpGs.
require(IlluminaHumanMethylation450kanno.ilmn12.hg19)
require(missMethyl)

# Get whole list of CpGs in the 450K array.
ann450k = getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
all <- ann450k@listData$Name

# Perform enrichment analysis for GO terms.
goenrichmnet_cpgs <- gometh(sig.cpg=sigCpGs, all.cpg=all, 
                            plot.bias=FALSE,array.type="450K",collection="GO") 
goenrichmnet_cpgs <- goenrichmnet_cpgs[order(goenrichmnet_cpgs$P.DE),]
head(goenrichmnet_cpgs)

# Perform enrichment analysis for KEGG terms.
KEGGenrichmnet_cpgs <- gometh(sig.cpg=sigCpGs, all.cpg=all,
                              plot.bias=FALSE,array.type="450K",
                              collection="KEGG") 
KEGGenrichmnet_cpgs <- KEGGenrichmnet_cpgs[order(KEGGenrichmnet_cpgs$P.DE),]
head(KEGGenrichmnet_cpgs)

```

The FEA show that these CpGs map genes participating in processes with noticeable sex differences such is the case of bone formation regulated by endocrine factors (“Endocrine and other factor-regulated calcium reabsorption”, hsa04961).

As always, the **DataSHIELD** session must be closed by:

```{r}
datashield.logout(conns)
```

# References.

<!--chapter:end:08-HELIX_DNAm.Rmd-->

# (PART) Technical details {.unnumbered}

# GWAS

TODO

# Internal structure of the PRS functionality

The PRS function can be divided into three main blocks that perform the required tasks to come up with the results. The three functional blocks are the following:

-   Client: Assemble the `prs_table` table if PGS Catalog is used, perform calls to the server to subset the resources and calculate the PRS with the subsetted resources.
-   Server resolver: Resolve the selected resources (VCF files) and subset them using the prs_table.
-   Server analysis: Use the resolved resources (small VCF files with only the SNPs of interest according to the `prs_table` table) to calculate the PRS.

In order to introduce a little how those three blocks work internally, schematized flow charts have been designed. To understand the exact inner working of the functionality it is advised to follow the flowcharts alongside the actual source code. Find the links to the three blocks source code, [client](https://github.com/isglobal-brge/dsOmicsClient/blob/master/R/ds.PRS.R), [server resolver](https://github.com/isglobal-brge/dsOmics/blob/master/R/GDSFileResourceClient.R#L43) and [server analysis](https://github.com/isglobal-brge/dsOmics/blob/master/R/PRSDS.R).

## Client

The client performs two basic tasks. The first one is to select between a user introduced `prs_table` or to retrieve the `prs_table` from the PGS Catalog. Please note that `prs_table` stands for Region Of Interest, which may not be the common term for PGS analysis but it makes sense since it refers to a table that contain the SNP's of interest and their weight to the score. If the user introduces a custom `prs_table` and a PGS Catalog ID, only the introduced table will be used, discarding the PGS Catalog ID information. Once this table is assembled, the next step is to call the required functions on the study servers. First, the resource resolver is called, and after that, the function that calculates the PRS is called.

This is illustrated on the following figure.

```{r block1Image, echo=FALSE, fig.cap="Flow chart of the client block.", fig.align='center'}
knitr::include_graphics("fig/block1.png")
```

## Server resolver

The server resolver is in charge of resolving the resources. The interesting aspect is that only a region of interest is actually assigned to the R session, this is to avoid overloading the memory with unnecessary information. There are two different methodologies to perform this subsetting, one is using chromosome names and position and the other is using the SNP id's. Due to the technical specification of VCF files, is much easier to perform the subsetting using chromosome names and positions because there is an indexing file for the VCF files to perform fast queries of regions by position. On the other hand, to filter a VCF file using SNP id's, the whole file has to be scanned, yielding a much slower process.

This block is illustrated on the following figure.

```{r block2Image, echo=FALSE, fig.cap="Flow chart of the server resolver block.", fig.align='center'}
knitr::include_graphics("fig/block2.png")
```

## Server analysis

Many processes are performed inside the analysis block. For that reason, more than a flow chart, a step by step guide has been illustrated with the objects that are created (or modified) on each step. The most important step on this block is making sure that the alternate (risk) alleles match between the VCF resources and the alternate alleles stated by the `prs_table` or PGS Catalog.

The block is illustrated on the following figure.

```{r block3Image, echo=FALSE, fig.cap="Flow chart of the server analysis block.", fig.align='center'}
knitr::include_graphics("fig/block3.png")
```

# Compression of GDS files vs. performance

When working with genotype data, OmicSHIELD offers the possibility of using VCF and GDS formats. When a VCF is supplied, internally is converted to a GDS to work with it, for that reason it is always better to start with a GDS to improve the performance of the pipeline.

When converting to GDS using [gdsfmt](https://bioconductor.org/packages/release/bioc/html/gdsfmt.html), there are many compression options that will affect the final file size. This compression comes with an added cost, which is the read time. For very aggressive compression typically the reading time gets severely affected, so it is good to find a good balance. To help choosing the right compression we provide a comparison table between all the compression options, the table has been extracted from the [official documentation](https://bioconductor.org/packages/release/bioc/vignettes/gdsfmt/inst/doc/gdsfmt.html) of the `gdsgmt` package.

| Compression Method    | Raw  | ZIP    | ZIP_ra | LZ4   | LZ4_ra | LZMA  | LZMA_ra |
|:----------------------|:-----|:-------|:-------|:------|:-------|:------|:--------|
| Data Size (MB)        | 38.1 | 1.9    | 2.1    | 2.8   | 2.9    | 1.4   | 1.4     |
| Compression Percent   | 100% | 5.08%  | 5.42%  | 7.39% | 7.60%  | 3.65% | 3.78%   |
| Reading Time (second) | 0.21 | 202.64 | 2.97   | 84.43 | 0.84   | 462.1 | 29.7    |

At ISGlobal we are using the `LZ4_ra` compression method because it provides a very good compression level with the least effect to the reading time.

<!--chapter:end:09-technical_stuff.Rmd-->

# (PART) Appendix {-}

# Session info
```{r session_info}
sessionInfo()
```

# Contributos
This bookdown has had the contributions by the following people.

-   Juan R Gonzalez, Associate Research Professor at Barcelona Institute for Global Health (ISGlobal) and Adjunct Professor at Department of Mathematics at Autonomous University of Barcelona (UAB).
-   Xavier Escribà-Montagut, PhD researcher at Barcelona Institute for Global Health (ISGlobal)

# (PART) References {-}

# References

<!--chapter:end:10-appendix.Rmd-->

